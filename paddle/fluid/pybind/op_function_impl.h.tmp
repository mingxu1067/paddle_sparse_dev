#pragma once

#include  "paddle/fluid/imperative/tracer.h"
namespace py = pybind11;
namespace paddle {
namespace pybind {

std::shared_ptr<imperative::VarBase> imperative_equal_all(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("equal_all", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("equal_all", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("equal_all", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("equal_all", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_not_equal(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("not_equal", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("not_equal", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("not_equal", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("not_equal", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_greater_equal(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("greater_equal", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("greater_equal", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("greater_equal", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("greater_equal", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_greater_than(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("greater_than", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("greater_than", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("greater_than", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("greater_than", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_less_equal(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("less_equal", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("less_equal", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("less_equal", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("less_equal", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_less_than(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("less_than", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("less_than", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("less_than", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("less_than", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_logical_xor(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("logical_xor", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("logical_xor", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("logical_xor", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("logical_xor", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_logical_not(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("logical_not", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("logical_not", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("logical_not", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_logical_or(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("logical_or", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("logical_or", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("logical_or", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("logical_or", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_mine_hard_examples(const py::handle& ClsLoss_,const py::handle& MatchIndices_,const py::handle& MatchDist_, const py::args& args)
{
  
  auto ClsLoss = CastPyHandleToVarBase("mine_hard_examples", "ClsLoss", 0, ClsLoss_, false);
  auto MatchIndices = CastPyHandleToVarBase("mine_hard_examples", "MatchIndices", 1, MatchIndices_, false);
  auto MatchDist = CastPyHandleToVarBase("mine_hard_examples", "MatchDist", 2, MatchDist_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("mine_hard_examples", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"NegIndices", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"UpdatedMatchIndices", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"ClsLoss", {ClsLoss}},{"MatchIndices", {MatchIndices}},{"MatchDist", {MatchDist}}};
    
    tracer->TraceOp("mine_hard_examples", ins, outs, attrs);
    return std::make_tuple(outs["NegIndices"][0],outs["UpdatedMatchIndices"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_prior_box(const py::handle& Input_,const py::handle& Image_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("prior_box", "Input", 0, Input_, false);
  auto Image = CastPyHandleToVarBase("prior_box", "Image", 1, Image_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("prior_box", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Boxes", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Variances", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"Image", {Image}}};
    
    tracer->TraceOp("prior_box", ins, outs, attrs);
    return std::make_tuple(outs["Boxes"][0],outs["Variances"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_anchor_generator(const py::handle& Input_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("anchor_generator", "Input", 0, Input_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("anchor_generator", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Anchors", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Variances", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}}};
    
    tracer->TraceOp("anchor_generator", ins, outs, attrs);
    return std::make_tuple(outs["Anchors"][0],outs["Variances"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_target_assign(const py::handle& X_,const py::handle& MatchIndices_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("target_assign", "X", 0, X_, false);
  auto MatchIndices = CastPyHandleToVarBase("target_assign", "MatchIndices", 1, MatchIndices_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("target_assign", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"OutWeight", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"MatchIndices", {MatchIndices}}};
    
    tracer->TraceOp("target_assign", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["OutWeight"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_retinanet_target_assign(const py::handle& Anchor_,const py::handle& GtBoxes_,const py::handle& GtLabels_,const py::handle& IsCrowd_,const py::handle& ImInfo_, const py::args& args)
{
  
  auto Anchor = CastPyHandleToVarBase("retinanet_target_assign", "Anchor", 0, Anchor_, false);
  auto GtBoxes = CastPyHandleToVarBase("retinanet_target_assign", "GtBoxes", 1, GtBoxes_, false);
  auto GtLabels = CastPyHandleToVarBase("retinanet_target_assign", "GtLabels", 2, GtLabels_, false);
  auto IsCrowd = CastPyHandleToVarBase("retinanet_target_assign", "IsCrowd", 3, IsCrowd_, false);
  auto ImInfo = CastPyHandleToVarBase("retinanet_target_assign", "ImInfo", 4, ImInfo_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("retinanet_target_assign", 5, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"LocationIndex", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"ScoreIndex", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"TargetBBox", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"TargetLabel", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"BBoxInsideWeight", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"ForegroundNumber", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Anchor", {Anchor}},{"GtBoxes", {GtBoxes}},{"GtLabels", {GtLabels}},{"IsCrowd", {IsCrowd}},{"ImInfo", {ImInfo}}};
    
    tracer->TraceOp("retinanet_target_assign", ins, outs, attrs);
    return std::make_tuple(outs["LocationIndex"][0],outs["ScoreIndex"][0],outs["TargetBBox"][0],outs["TargetLabel"][0],outs["BBoxInsideWeight"][0],outs["ForegroundNumber"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_rpn_target_assign(const py::handle& Anchor_,const py::handle& GtBoxes_,const py::handle& IsCrowd_,const py::handle& ImInfo_, const py::args& args)
{
  
  auto Anchor = CastPyHandleToVarBase("rpn_target_assign", "Anchor", 0, Anchor_, false);
  auto GtBoxes = CastPyHandleToVarBase("rpn_target_assign", "GtBoxes", 1, GtBoxes_, false);
  auto IsCrowd = CastPyHandleToVarBase("rpn_target_assign", "IsCrowd", 2, IsCrowd_, false);
  auto ImInfo = CastPyHandleToVarBase("rpn_target_assign", "ImInfo", 3, ImInfo_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("rpn_target_assign", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"LocationIndex", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"ScoreIndex", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"TargetBBox", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"TargetLabel", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"BBoxInsideWeight", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Anchor", {Anchor}},{"GtBoxes", {GtBoxes}},{"IsCrowd", {IsCrowd}},{"ImInfo", {ImInfo}}};
    
    tracer->TraceOp("rpn_target_assign", ins, outs, attrs);
    return std::make_tuple(outs["LocationIndex"][0],outs["ScoreIndex"][0],outs["TargetBBox"][0],outs["TargetLabel"][0],outs["BBoxInsideWeight"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_generate_proposal_labels(const py::handle& RpnRois_,const py::handle& GtClasses_,const py::handle& IsCrowd_,const py::handle& GtBoxes_,const py::handle& ImInfo_, const py::args& args)
{
  
  auto RpnRois = CastPyHandleToVarBase("generate_proposal_labels", "RpnRois", 0, RpnRois_, false);
  auto GtClasses = CastPyHandleToVarBase("generate_proposal_labels", "GtClasses", 1, GtClasses_, false);
  auto IsCrowd = CastPyHandleToVarBase("generate_proposal_labels", "IsCrowd", 2, IsCrowd_, false);
  auto GtBoxes = CastPyHandleToVarBase("generate_proposal_labels", "GtBoxes", 3, GtBoxes_, false);
  auto ImInfo = CastPyHandleToVarBase("generate_proposal_labels", "ImInfo", 4, ImInfo_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("generate_proposal_labels", 5, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Rois", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"LabelsInt32", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"BboxTargets", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"BboxInsideWeights", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"BboxOutsideWeights", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"MaxOverlapWithGT", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"RpnRois", {RpnRois}},{"GtClasses", {GtClasses}},{"IsCrowd", {IsCrowd}},{"GtBoxes", {GtBoxes}},{"ImInfo", {ImInfo}}};
    
    tracer->TraceOp("generate_proposal_labels", ins, outs, attrs);
    return std::make_tuple(outs["Rois"][0],outs["LabelsInt32"][0],outs["BboxTargets"][0],outs["BboxInsideWeights"][0],outs["BboxOutsideWeights"][0],outs["MaxOverlapWithGT"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_multiclass_nms2(const py::handle& BBoxes_,const py::handle& Scores_, const py::args& args)
{
  
  auto BBoxes = CastPyHandleToVarBase("multiclass_nms2", "BBoxes", 0, BBoxes_, false);
  auto Scores = CastPyHandleToVarBase("multiclass_nms2", "Scores", 1, Scores_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("multiclass_nms2", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Index", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"BBoxes", {BBoxes}},{"Scores", {Scores}}};
    
    tracer->TraceOp("multiclass_nms2", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["Index"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_locality_aware_nms(const py::handle& BBoxes_,const py::handle& Scores_, const py::args& args)
{
  
  auto BBoxes = CastPyHandleToVarBase("locality_aware_nms", "BBoxes", 0, BBoxes_, false);
  auto Scores = CastPyHandleToVarBase("locality_aware_nms", "Scores", 1, Scores_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("locality_aware_nms", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"BBoxes", {BBoxes}},{"Scores", {Scores}}};
    
    tracer->TraceOp("locality_aware_nms", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_matrix_nms(const py::handle& BBoxes_,const py::handle& Scores_, const py::args& args)
{
  
  auto BBoxes = CastPyHandleToVarBase("matrix_nms", "BBoxes", 0, BBoxes_, false);
  auto Scores = CastPyHandleToVarBase("matrix_nms", "Scores", 1, Scores_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("matrix_nms", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Index", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"RoisNum", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"BBoxes", {BBoxes}},{"Scores", {Scores}}};
    
    tracer->TraceOp("matrix_nms", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["Index"][0],outs["RoisNum"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_box_clip(const py::handle& Input_,const py::handle& ImInfo_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("box_clip", "Input", 0, Input_, false);
  auto ImInfo = CastPyHandleToVarBase("box_clip", "ImInfo", 1, ImInfo_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("box_clip", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Output", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"ImInfo", {ImInfo}}};
    
    tracer->TraceOp("box_clip", ins, outs, attrs);
    return outs["Output"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_bipartite_match(const py::handle& DistMat_, const py::args& args)
{
  
  auto DistMat = CastPyHandleToVarBase("bipartite_match", "DistMat", 0, DistMat_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("bipartite_match", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"ColToRowMatchIndices", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"ColToRowMatchDist", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"DistMat", {DistMat}}};
    
    tracer->TraceOp("bipartite_match", ins, outs, attrs);
    return std::make_tuple(outs["ColToRowMatchIndices"][0],outs["ColToRowMatchDist"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sigmoid_focal_loss(const py::handle& X_,const py::handle& Label_,const py::handle& FgNum_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sigmoid_focal_loss", "X", 0, X_, false);
  auto Label = CastPyHandleToVarBase("sigmoid_focal_loss", "Label", 1, Label_, false);
  auto FgNum = CastPyHandleToVarBase("sigmoid_focal_loss", "FgNum", 2, FgNum_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sigmoid_focal_loss", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Label", {Label}},{"FgNum", {FgNum}}};
    
    tracer->TraceOp("sigmoid_focal_loss", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_gather_tree(const py::handle& Ids_,const py::handle& Parents_, const py::args& args)
{
  
  auto Ids = CastPyHandleToVarBase("gather_tree", "Ids", 0, Ids_, false);
  auto Parents = CastPyHandleToVarBase("gather_tree", "Parents", 1, Parents_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("gather_tree", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Ids", {Ids}},{"Parents", {Parents}}};
    
    tracer->TraceOp("gather_tree", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_gaussian_random(const py::args& args)
{
  
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("gaussian_random", 0, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {};
    
    tracer->TraceOp("gaussian_random", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_gelu(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("gelu", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("gelu", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("gelu", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_get_tensor_from_selected_rows(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("get_tensor_from_selected_rows", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("get_tensor_from_selected_rows", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("get_tensor_from_selected_rows", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sequence_expand_as(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sequence_expand_as", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("sequence_expand_as", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sequence_expand_as", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("sequence_expand_as", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_lookup_table_v2(const py::handle& W_,const py::handle& Ids_, const py::args& args)
{
  
  auto W = CastPyHandleToVarBase("lookup_table_v2", "W", 0, W_, false);
  auto Ids = CastPyHandleToVarBase("lookup_table_v2", "Ids", 1, Ids_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("lookup_table_v2", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"W", {W}},{"Ids", {Ids}}};
    
    tracer->TraceOp("lookup_table_v2", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_pad2d(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("pad2d", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("pad2d", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("pad2d", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_size(const py::handle& Input_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("size", "Input", 0, Input_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("size", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}}};
    
    tracer->TraceOp("size", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_hinge_loss(const py::handle& Logits_,const py::handle& Labels_, const py::args& args)
{
  
  auto Logits = CastPyHandleToVarBase("hinge_loss", "Logits", 0, Logits_, false);
  auto Labels = CastPyHandleToVarBase("hinge_loss", "Labels", 1, Labels_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("hinge_loss", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Loss", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Logits", {Logits}},{"Labels", {Labels}}};
    
    tracer->TraceOp("hinge_loss", ins, outs, attrs);
    return outs["Loss"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_conv2d_transpose(const py::handle& Input_,const py::handle& Filter_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("conv2d_transpose", "Input", 0, Input_, false);
  auto Filter = CastPyHandleToVarBase("conv2d_transpose", "Filter", 1, Filter_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("conv2d_transpose", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Output", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"Filter", {Filter}}};
    
    tracer->TraceOp("conv2d_transpose", ins, outs, attrs);
    return outs["Output"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_huber_loss(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("huber_loss", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("huber_loss", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("huber_loss", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Residual", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("huber_loss", ins, outs, attrs);
    return std::make_tuple(outs["Residual"][0],outs["Out"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_pixel_shuffle(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("pixel_shuffle", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("pixel_shuffle", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("pixel_shuffle", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_increment(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("increment", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("increment", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("increment", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_inplace_abn(const py::handle& X_,const py::handle& Scale_,const py::handle& Bias_,const py::handle& Mean_,const py::handle& Variance_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("inplace_abn", "X", 0, X_, false);
  auto Scale = CastPyHandleToVarBase("inplace_abn", "Scale", 1, Scale_, false);
  auto Bias = CastPyHandleToVarBase("inplace_abn", "Bias", 2, Bias_, false);
  auto Mean = CastPyHandleToVarBase("inplace_abn", "Mean", 3, Mean_, false);
  auto Variance = CastPyHandleToVarBase("inplace_abn", "Variance", 4, Variance_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("inplace_abn", 5, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Y", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"MeanOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"VarianceOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SavedMean", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SavedVariance", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Scale", {Scale}},{"Bias", {Bias}},{"Mean", {Mean}},{"Variance", {Variance}}};
    
    tracer->TraceOp("inplace_abn", ins, outs, attrs);
    return std::make_tuple(outs["Y"][0],outs["MeanOut"][0],outs["VarianceOut"][0],outs["SavedMean"][0],outs["SavedVariance"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sinh(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sinh", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sinh", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("sinh", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_trilinear_interp(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("trilinear_interp", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("trilinear_interp", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("trilinear_interp", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_thresholded_relu(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("thresholded_relu", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("thresholded_relu", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("thresholded_relu", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::vector<std::shared_ptr<imperative::VarBase>> imperative_pull_sparse(const py::handle& Ids_,const py::handle& W_,size_t OutNum, const py::args& args)
{
  
  auto Ids = CastPyHandleToVarBaseList("pull_sparse", "Ids", 0, Ids_, false);
  auto W = CastPyHandleToVarBaseList("pull_sparse", "W", 1, W_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("pull_sparse", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", ConstructDuplicableOutput(OutNum)}};
    imperative::NameVarBaseMap ins = {{"Ids", Ids},{"W", W}};
    
    tracer->TraceOp("pull_sparse", ins, outs, attrs);
    return outs["Out"]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_linear_interp_v2(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("linear_interp_v2", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("linear_interp_v2", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("linear_interp_v2", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_yolov3_loss(const py::handle& X_,const py::handle& GTBox_,const py::handle& GTLabel_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("yolov3_loss", "X", 0, X_, false);
  auto GTBox = CastPyHandleToVarBase("yolov3_loss", "GTBox", 1, GTBox_, false);
  auto GTLabel = CastPyHandleToVarBase("yolov3_loss", "GTLabel", 2, GTLabel_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("yolov3_loss", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Loss", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"ObjectnessMask", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"GTMatchMask", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"GTBox", {GTBox}},{"GTLabel", {GTLabel}}};
    
    tracer->TraceOp("yolov3_loss", ins, outs, attrs);
    return std::make_tuple(outs["Loss"][0],outs["ObjectnessMask"][0],outs["GTMatchMask"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_hard_shrink(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("hard_shrink", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("hard_shrink", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("hard_shrink", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_elu(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("elu", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("elu", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("elu", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_bilinear_interp_v2(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("bilinear_interp_v2", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("bilinear_interp_v2", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("bilinear_interp_v2", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_cross(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("cross", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("cross", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("cross", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("cross", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_inverse(const py::handle& Input_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("inverse", "Input", 0, Input_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("inverse", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Output", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}}};
    
    tracer->TraceOp("inverse", ins, outs, attrs);
    return outs["Output"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_reduce_max(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("reduce_max", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("reduce_max", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("reduce_max", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_hash(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("hash", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("hash", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("hash", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_grid_sampler(const py::handle& X_,const py::handle& Grid_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("grid_sampler", "X", 0, X_, false);
  auto Grid = CastPyHandleToVarBase("grid_sampler", "Grid", 1, Grid_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("grid_sampler", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Output", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Grid", {Grid}}};
    
    tracer->TraceOp("grid_sampler", ins, outs, attrs);
    return outs["Output"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_squeeze(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("squeeze", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("squeeze", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("squeeze", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_one_hot_v2(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("one_hot_v2", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("one_hot_v2", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("one_hot_v2", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_isnan(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("isnan", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("isnan", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("isnan", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_dot(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("dot", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("dot", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("dot", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("dot", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_ncclReduce(const py::handle& X_,const py::handle& Communicator_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("ncclReduce", "X", 0, X_, false);
  auto Communicator = CastPyHandleToVarBase("ncclReduce", "Communicator", 1, Communicator_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("ncclReduce", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Communicator", {Communicator}}};
    
    tracer->TraceOp("ncclReduce", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_hierarchical_sigmoid(const py::handle& X_,const py::handle& W_,const py::handle& Label_,const py::handle& PathTable_,const py::handle& PathCode_,const py::handle& Bias_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("hierarchical_sigmoid", "X", 0, X_, false);
  auto W = CastPyHandleToVarBase("hierarchical_sigmoid", "W", 1, W_, false);
  auto Label = CastPyHandleToVarBase("hierarchical_sigmoid", "Label", 2, Label_, false);
  auto PathTable = CastPyHandleToVarBase("hierarchical_sigmoid", "PathTable", 3, PathTable_, true);
  auto PathCode = CastPyHandleToVarBase("hierarchical_sigmoid", "PathCode", 4, PathCode_, true);
  auto Bias = CastPyHandleToVarBase("hierarchical_sigmoid", "Bias", 5, Bias_, true);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("hierarchical_sigmoid", 6, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"PreOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"W_Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"W", {W}},{"Label", {Label}}};
    	
    if (PathTable != nullptr) {	
      ins["PathTable"] = {PathTable};	
    }	
	
    if (PathCode != nullptr) {	
      ins["PathCode"] = {PathCode};	
    }	
	
    if (Bias != nullptr) {	
      ins["Bias"] = {Bias};	
    }	

    tracer->TraceOp("hierarchical_sigmoid", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["PreOut"][0],outs["W_Out"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_isinf(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("isinf", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("isinf", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("isinf", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_isfinite_v2(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("isfinite_v2", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("isfinite_v2", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("isfinite_v2", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_clip_by_norm(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("clip_by_norm", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("clip_by_norm", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("clip_by_norm", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_index_sample(const py::handle& X_,const py::handle& Index_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("index_sample", "X", 0, X_, false);
  auto Index = CastPyHandleToVarBase("index_sample", "Index", 1, Index_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("index_sample", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Index", {Index}}};
    
    tracer->TraceOp("index_sample", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_partial_sum(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBaseList("partial_sum", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("partial_sum", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", X}};
    
    tracer->TraceOp("partial_sum", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_layer_norm(const py::handle& X_,const py::handle& Scale_,const py::handle& Bias_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("layer_norm", "X", 0, X_, false);
  auto Scale = CastPyHandleToVarBase("layer_norm", "Scale", 1, Scale_, true);
  auto Bias = CastPyHandleToVarBase("layer_norm", "Bias", 2, Bias_, true);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("layer_norm", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Y", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Mean", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Variance", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    	
    if (Scale != nullptr) {	
      ins["Scale"] = {Scale};	
    }	
	
    if (Bias != nullptr) {	
      ins["Bias"] = {Bias};	
    }	

    tracer->TraceOp("layer_norm", ins, outs, attrs);
    return std::make_tuple(outs["Y"][0],outs["Mean"][0],outs["Variance"][0]); 
  }   
}

std::vector<std::shared_ptr<imperative::VarBase>> imperative_load_combine(size_t OutNum, const py::args& args)
{
  
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("load_combine", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", ConstructDuplicableOutput(OutNum)}};
    imperative::NameVarBaseMap ins = {};
    
    tracer->TraceOp("load_combine", ins, outs, attrs);
    return outs["Out"]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sequence_erase(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sequence_erase", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sequence_erase", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("sequence_erase", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_log_loss(const py::handle& Predicted_,const py::handle& Labels_, const py::args& args)
{
  
  auto Predicted = CastPyHandleToVarBase("log_loss", "Predicted", 0, Predicted_, false);
  auto Labels = CastPyHandleToVarBase("log_loss", "Labels", 1, Labels_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("log_loss", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Loss", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Predicted", {Predicted}},{"Labels", {Labels}}};
    
    tracer->TraceOp("log_loss", ins, outs, attrs);
    return outs["Loss"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_log_softmax(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("log_softmax", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("log_softmax", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("log_softmax", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_asin(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("asin", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("asin", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("asin", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_box_coder(const py::handle& PriorBox_,const py::handle& PriorBoxVar_,const py::handle& TargetBox_, const py::args& args)
{
  
  auto PriorBox = CastPyHandleToVarBase("box_coder", "PriorBox", 0, PriorBox_, false);
  auto PriorBoxVar = CastPyHandleToVarBase("box_coder", "PriorBoxVar", 1, PriorBoxVar_, true);
  auto TargetBox = CastPyHandleToVarBase("box_coder", "TargetBox", 2, TargetBox_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("box_coder", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"OutputBox", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"PriorBox", {PriorBox}},{"TargetBox", {TargetBox}}};
    	
    if (PriorBoxVar != nullptr) {	
      ins["PriorBoxVar"] = {PriorBoxVar};	
    }	

    tracer->TraceOp("box_coder", ins, outs, attrs);
    return outs["OutputBox"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_correlation(const py::handle& Input1_,const py::handle& Input2_, const py::args& args)
{
  
  auto Input1 = CastPyHandleToVarBase("correlation", "Input1", 0, Input1_, false);
  auto Input2 = CastPyHandleToVarBase("correlation", "Input2", 1, Input2_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("correlation", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Output", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input1", {Input1}},{"Input2", {Input2}}};
    
    tracer->TraceOp("correlation", ins, outs, attrs);
    return outs["Output"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_lrn(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("lrn", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("lrn", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"MidOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("lrn", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["MidOut"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_nearest_interp_v2(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("nearest_interp_v2", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("nearest_interp_v2", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("nearest_interp_v2", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_lstm_unit(const py::handle& X_,const py::handle& C_prev_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("lstm_unit", "X", 0, X_, false);
  auto C_prev = CastPyHandleToVarBase("lstm_unit", "C_prev", 1, C_prev_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("lstm_unit", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"C", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"H", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"C_prev", {C_prev}}};
    
    tracer->TraceOp("lstm_unit", ins, outs, attrs);
    return std::make_tuple(outs["C"][0],outs["H"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_margin_rank_loss(const py::handle& X1_,const py::handle& X2_,const py::handle& Label_, const py::args& args)
{
  
  auto X1 = CastPyHandleToVarBase("margin_rank_loss", "X1", 0, X1_, false);
  auto X2 = CastPyHandleToVarBase("margin_rank_loss", "X2", 1, X2_, false);
  auto Label = CastPyHandleToVarBase("margin_rank_loss", "Label", 2, Label_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("margin_rank_loss", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Activated", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X1", {X1}},{"X2", {X2}},{"Label", {Label}}};
    
    tracer->TraceOp("margin_rank_loss", ins, outs, attrs);
    return std::make_tuple(outs["Activated"][0],outs["Out"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_masked_select(const py::handle& X_,const py::handle& Mask_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("masked_select", "X", 0, X_, false);
  auto Mask = CastPyHandleToVarBase("masked_select", "Mask", 1, Mask_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("masked_select", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Y", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Mask", {Mask}}};
    
    tracer->TraceOp("masked_select", ins, outs, attrs);
    return outs["Y"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_matmul(const py::handle& X_,const py::handle& Y_,std::shared_ptr<imperative::VarBase>Out, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("matmul", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("matmul", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("matmul", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {Out}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("matmul", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_matmul_v2(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("matmul_v2", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("matmul_v2", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("matmul_v2", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("matmul_v2", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_multiclass_nms3(const py::handle& BBoxes_,const py::handle& Scores_,const py::handle& RoisNum_, const py::args& args)
{
  
  auto BBoxes = CastPyHandleToVarBase("multiclass_nms3", "BBoxes", 0, BBoxes_, false);
  auto Scores = CastPyHandleToVarBase("multiclass_nms3", "Scores", 1, Scores_, false);
  auto RoisNum = CastPyHandleToVarBase("multiclass_nms3", "RoisNum", 2, RoisNum_, true);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("multiclass_nms3", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Index", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"NmsRoisNum", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"BBoxes", {BBoxes}},{"Scores", {Scores}}};
    	
    if (RoisNum != nullptr) {	
      ins["RoisNum"] = {RoisNum};	
    }	

    tracer->TraceOp("multiclass_nms3", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["Index"][0],outs["NmsRoisNum"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_eye(const py::args& args)
{
  
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("eye", 0, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {};
    
    tracer->TraceOp("eye", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_isfinite(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("isfinite", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("isfinite", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("isfinite", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_im2sequence(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("im2sequence", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("im2sequence", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("im2sequence", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_crf_decoding(const py::handle& Emission_,const py::handle& Transition_, const py::args& args)
{
  
  auto Emission = CastPyHandleToVarBase("crf_decoding", "Emission", 0, Emission_, false);
  auto Transition = CastPyHandleToVarBase("crf_decoding", "Transition", 1, Transition_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("crf_decoding", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"ViterbiPath", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Emission", {Emission}},{"Transition", {Transition}}};
    
    tracer->TraceOp("crf_decoding", ins, outs, attrs);
    return outs["ViterbiPath"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_fused_embedding_seq_pool(const py::handle& W_,const py::handle& Ids_, const py::args& args)
{
  
  auto W = CastPyHandleToVarBase("fused_embedding_seq_pool", "W", 0, W_, false);
  auto Ids = CastPyHandleToVarBase("fused_embedding_seq_pool", "Ids", 1, Ids_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fused_embedding_seq_pool", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"W", {W}},{"Ids", {Ids}}};
    
    tracer->TraceOp("fused_embedding_seq_pool", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_mean_iou(const py::handle& Predictions_,const py::handle& Labels_, const py::args& args)
{
  
  auto Predictions = CastPyHandleToVarBase("mean_iou", "Predictions", 0, Predictions_, false);
  auto Labels = CastPyHandleToVarBase("mean_iou", "Labels", 1, Labels_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("mean_iou", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"OutMeanIou", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"OutWrong", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"OutCorrect", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Predictions", {Predictions}},{"Labels", {Labels}}};
    
    tracer->TraceOp("mean_iou", ins, outs, attrs);
    return std::make_tuple(outs["OutMeanIou"][0],outs["OutWrong"][0],outs["OutCorrect"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_merge_selected_rows(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("merge_selected_rows", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("merge_selected_rows", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("merge_selected_rows", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::vector<std::shared_ptr<imperative::VarBase>> imperative_meshgrid(const py::handle& X_,size_t OutNum, const py::args& args)
{
  
  auto X = CastPyHandleToVarBaseList("meshgrid", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("meshgrid", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", ConstructDuplicableOutput(OutNum)}};
    imperative::NameVarBaseMap ins = {{"X", X}};
    
    tracer->TraceOp("meshgrid", ins, outs, attrs);
    return outs["Out"]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_argsort(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("argsort", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("argsort", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Indices", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("argsort", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["Indices"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_minus(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("minus", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("minus", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("minus", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("minus", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_adadelta(const py::handle& Param_,const py::handle& Grad_,const py::handle& AvgSquaredGrad_,const py::handle& AvgSquaredUpdate_, const py::args& args)
{
  
  auto Param = CastPyHandleToVarBase("adadelta", "Param", 0, Param_, false);
  auto Grad = CastPyHandleToVarBase("adadelta", "Grad", 1, Grad_, false);
  auto AvgSquaredGrad = CastPyHandleToVarBase("adadelta", "AvgSquaredGrad", 2, AvgSquaredGrad_, false);
  auto AvgSquaredUpdate = CastPyHandleToVarBase("adadelta", "AvgSquaredUpdate", 3, AvgSquaredUpdate_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("adadelta", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"ParamOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"AvgSquaredGradOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"AvgSquaredUpdateOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Param", {Param}},{"Grad", {Grad}},{"AvgSquaredGrad", {AvgSquaredGrad}},{"AvgSquaredUpdate", {AvgSquaredUpdate}}};
    
    tracer->TraceOp("adadelta", ins, outs, attrs);
    return std::make_tuple(outs["ParamOut"][0],outs["AvgSquaredGradOut"][0],outs["AvgSquaredUpdateOut"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_lod_reset(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("lod_reset", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("lod_reset", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("lod_reset", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_mish(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("mish", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("mish", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("mish", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_modified_huber_loss(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("modified_huber_loss", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("modified_huber_loss", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("modified_huber_loss", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"IntermediateVal", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("modified_huber_loss", ins, outs, attrs);
    return std::make_tuple(outs["IntermediateVal"][0],outs["Out"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_skip_layernorm(const py::handle& X_,const py::handle& Y_,const py::handle& Scale_,const py::handle& Bias_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("skip_layernorm", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("skip_layernorm", "Y", 1, Y_, false);
  auto Scale = CastPyHandleToVarBase("skip_layernorm", "Scale", 2, Scale_, false);
  auto Bias = CastPyHandleToVarBase("skip_layernorm", "Bias", 3, Bias_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("skip_layernorm", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}},{"Scale", {Scale}},{"Bias", {Bias}}};
    
    tracer->TraceOp("skip_layernorm", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_mul(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("mul", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("mul", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("mul", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("mul", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_log10(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("log10", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("log10", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("log10", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_proximal_gd(const py::handle& Param_,const py::handle& Grad_,const py::handle& LearningRate_, const py::args& args)
{
  
  auto Param = CastPyHandleToVarBase("proximal_gd", "Param", 0, Param_, false);
  auto Grad = CastPyHandleToVarBase("proximal_gd", "Grad", 1, Grad_, false);
  auto LearningRate = CastPyHandleToVarBase("proximal_gd", "LearningRate", 2, LearningRate_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("proximal_gd", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"ParamOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Param", {Param}},{"Grad", {Grad}},{"LearningRate", {LearningRate}}};
    
    tracer->TraceOp("proximal_gd", ins, outs, attrs);
    return outs["ParamOut"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_multinomial(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("multinomial", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("multinomial", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("multinomial", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_dgc_clip_by_norm(const py::handle& current_step_,const py::handle& X_, const py::args& args)
{
  
  auto current_step = CastPyHandleToVarBase("dgc_clip_by_norm", "current_step", 0, current_step_, false);
  auto X = CastPyHandleToVarBase("dgc_clip_by_norm", "X", 1, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("dgc_clip_by_norm", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"current_step", {current_step}},{"X", {X}}};
    
    tracer->TraceOp("dgc_clip_by_norm", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_bilateral_slice(const py::handle& X_,const py::handle& Grid_,const py::handle& Guide_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("bilateral_slice", "X", 0, X_, false);
  auto Grid = CastPyHandleToVarBase("bilateral_slice", "Grid", 1, Grid_, false);
  auto Guide = CastPyHandleToVarBase("bilateral_slice", "Guide", 2, Guide_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("bilateral_slice", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Grid", {Grid}},{"Guide", {Guide}}};
    
    tracer->TraceOp("bilateral_slice", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_multiplex(const py::handle& Ids_,const py::handle& X_, const py::args& args)
{
  
  auto Ids = CastPyHandleToVarBase("multiplex", "Ids", 0, Ids_, false);
  auto X = CastPyHandleToVarBaseList("multiplex", "X", 1, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("multiplex", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Ids", {Ids}},{"X", X}};
    
    tracer->TraceOp("multiplex", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_nll_loss(const py::handle& X_,const py::handle& Label_,const py::handle& Weight_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("nll_loss", "X", 0, X_, false);
  auto Label = CastPyHandleToVarBase("nll_loss", "Label", 1, Label_, false);
  auto Weight = CastPyHandleToVarBase("nll_loss", "Weight", 2, Weight_, true);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("nll_loss", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Total_weight", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Label", {Label}}};
    	
    if (Weight != nullptr) {	
      ins["Weight"] = {Weight};	
    }	

    tracer->TraceOp("nll_loss", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["Total_weight"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sequence_expand(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sequence_expand", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("sequence_expand", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sequence_expand", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("sequence_expand", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::vector<std::shared_ptr<imperative::VarBase>> imperative_unbind(const py::handle& X_,size_t OutNum, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("unbind", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("unbind", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", ConstructDuplicableOutput(OutNum)}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("unbind", ins, outs, attrs);
    return outs["Out"]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_linear_chain_crf(const py::handle& Emission_,const py::handle& Transition_,const py::handle& Label_, const py::args& args)
{
  
  auto Emission = CastPyHandleToVarBase("linear_chain_crf", "Emission", 0, Emission_, false);
  auto Transition = CastPyHandleToVarBase("linear_chain_crf", "Transition", 1, Transition_, false);
  auto Label = CastPyHandleToVarBase("linear_chain_crf", "Label", 2, Label_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("linear_chain_crf", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Alpha", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"EmissionExps", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"TransitionExps", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"LogLikelihood", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Emission", {Emission}},{"Transition", {Transition}},{"Label", {Label}}};
    
    tracer->TraceOp("linear_chain_crf", ins, outs, attrs);
    return std::make_tuple(outs["Alpha"][0],outs["EmissionExps"][0],outs["TransitionExps"][0],outs["LogLikelihood"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_norm(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("norm", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("norm", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Norm", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("norm", ins, outs, attrs);
    return std::make_tuple(outs["Norm"][0],outs["Out"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_lstm(const py::handle& Input_,const py::handle& Weight_,const py::handle& Bias_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("lstm", "Input", 0, Input_, false);
  auto Weight = CastPyHandleToVarBase("lstm", "Weight", 1, Weight_, false);
  auto Bias = CastPyHandleToVarBase("lstm", "Bias", 2, Bias_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("lstm", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Hidden", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Cell", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"BatchGate", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"BatchCellPreAct", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"Weight", {Weight}},{"Bias", {Bias}}};
    
    tracer->TraceOp("lstm", ins, outs, attrs);
    return std::make_tuple(outs["Hidden"][0],outs["Cell"][0],outs["BatchGate"][0],outs["BatchCellPreAct"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_mean(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("mean", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("mean", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("mean", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_filter_by_instag(const py::handle& Ins_,const py::handle& Ins_tag_,const py::handle& Filter_tag_, const py::args& args)
{
  
  auto Ins = CastPyHandleToVarBase("filter_by_instag", "Ins", 0, Ins_, false);
  auto Ins_tag = CastPyHandleToVarBase("filter_by_instag", "Ins_tag", 1, Ins_tag_, false);
  auto Filter_tag = CastPyHandleToVarBase("filter_by_instag", "Filter_tag", 2, Filter_tag_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("filter_by_instag", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"LossWeight", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"IndexMap", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Ins", {Ins}},{"Ins_tag", {Ins_tag}},{"Filter_tag", {Filter_tag}}};
    
    tracer->TraceOp("filter_by_instag", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["LossWeight"][0],outs["IndexMap"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sequence_scatter(const py::handle& X_,const py::handle& Ids_,const py::handle& Updates_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sequence_scatter", "X", 0, X_, false);
  auto Ids = CastPyHandleToVarBase("sequence_scatter", "Ids", 1, Ids_, false);
  auto Updates = CastPyHandleToVarBase("sequence_scatter", "Updates", 2, Updates_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sequence_scatter", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Ids", {Ids}},{"Updates", {Updates}}};
    
    tracer->TraceOp("sequence_scatter", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_p_norm(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("p_norm", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("p_norm", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("p_norm", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_load(const py::args& args)
{
  
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("load", 0, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {};
    
    tracer->TraceOp("load", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_expand_v2(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("expand_v2", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("expand_v2", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("expand_v2", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_mv(const py::handle& X_,const py::handle& Vec_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("mv", "X", 0, X_, false);
  auto Vec = CastPyHandleToVarBase("mv", "Vec", 1, Vec_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("mv", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Vec", {Vec}}};
    
    tracer->TraceOp("mv", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_detection_map(const py::handle& DetectRes_,const py::handle& Label_, const py::args& args)
{
  
  auto DetectRes = CastPyHandleToVarBase("detection_map", "DetectRes", 0, DetectRes_, false);
  auto Label = CastPyHandleToVarBase("detection_map", "Label", 1, Label_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("detection_map", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"AccumPosCount", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"AccumTruePos", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"AccumFalsePos", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"MAP", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"DetectRes", {DetectRes}},{"Label", {Label}}};
    
    tracer->TraceOp("detection_map", ins, outs, attrs);
    return std::make_tuple(outs["AccumPosCount"][0],outs["AccumTruePos"][0],outs["AccumFalsePos"][0],outs["MAP"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_fused_elemwise_activation(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fused_elemwise_activation", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("fused_elemwise_activation", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fused_elemwise_activation", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"IntermediateOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("fused_elemwise_activation", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["IntermediateOut"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_pool3d(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("pool3d", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("pool3d", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("pool3d", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_pool2d(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("pool2d", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("pool2d", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("pool2d", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_max_pool2d_with_index(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("max_pool2d_with_index", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("max_pool2d_with_index", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Mask", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("max_pool2d_with_index", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["Mask"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_polygon_box_transform(const py::handle& Input_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("polygon_box_transform", "Input", 0, Input_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("polygon_box_transform", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Output", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}}};
    
    tracer->TraceOp("polygon_box_transform", ins, outs, attrs);
    return outs["Output"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_center_loss(const py::handle& X_,const py::handle& Label_,const py::handle& Centers_,const py::handle& CenterUpdateRate_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("center_loss", "X", 0, X_, false);
  auto Label = CastPyHandleToVarBase("center_loss", "Label", 1, Label_, false);
  auto Centers = CastPyHandleToVarBase("center_loss", "Centers", 2, Centers_, false);
  auto CenterUpdateRate = CastPyHandleToVarBase("center_loss", "CenterUpdateRate", 3, CenterUpdateRate_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("center_loss", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"CentersOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SampleCenterDiff", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Loss", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Label", {Label}},{"Centers", {Centers}},{"CenterUpdateRate", {CenterUpdateRate}}};
    
    tracer->TraceOp("center_loss", ins, outs, attrs);
    return std::make_tuple(outs["CentersOut"][0],outs["SampleCenterDiff"][0],outs["Loss"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_positive_negative_pair(const py::handle& Score_,const py::handle& Label_,const py::handle& QueryID_, const py::args& args)
{
  
  auto Score = CastPyHandleToVarBase("positive_negative_pair", "Score", 0, Score_, false);
  auto Label = CastPyHandleToVarBase("positive_negative_pair", "Label", 1, Label_, false);
  auto QueryID = CastPyHandleToVarBase("positive_negative_pair", "QueryID", 2, QueryID_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("positive_negative_pair", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"PositivePair", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"NegativePair", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Score", {Score}},{"Label", {Label}},{"QueryID", {QueryID}}};
    
    tracer->TraceOp("positive_negative_pair", ins, outs, attrs);
    return std::make_tuple(outs["PositivePair"][0],outs["NegativePair"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_fused_embedding_eltwise_layernorm(const py::handle& Ids_,const py::handle& Embs_,const py::handle& Bias_,const py::handle& Scale_, const py::args& args)
{
  
  auto Ids = CastPyHandleToVarBaseList("fused_embedding_eltwise_layernorm", "Ids", 0, Ids_, false);
  auto Embs = CastPyHandleToVarBaseList("fused_embedding_eltwise_layernorm", "Embs", 1, Embs_, false);
  auto Bias = CastPyHandleToVarBase("fused_embedding_eltwise_layernorm", "Bias", 2, Bias_, false);
  auto Scale = CastPyHandleToVarBase("fused_embedding_eltwise_layernorm", "Scale", 3, Scale_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fused_embedding_eltwise_layernorm", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Ids", Ids},{"Embs", Embs},{"Bias", {Bias}},{"Scale", {Scale}}};
    
    tracer->TraceOp("fused_embedding_eltwise_layernorm", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_nearest_interp(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("nearest_interp", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("nearest_interp", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("nearest_interp", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_softmax_with_cross_entropy(const py::handle& Logits_,const py::handle& Label_, const py::args& args)
{
  
  auto Logits = CastPyHandleToVarBase("softmax_with_cross_entropy", "Logits", 0, Logits_, false);
  auto Label = CastPyHandleToVarBase("softmax_with_cross_entropy", "Label", 1, Label_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("softmax_with_cross_entropy", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Softmax", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Loss", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Logits", {Logits}},{"Label", {Label}}};
    
    tracer->TraceOp("softmax_with_cross_entropy", ins, outs, attrs);
    return std::make_tuple(outs["Softmax"][0],outs["Loss"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_scatter(const py::handle& X_,const py::handle& Ids_,const py::handle& Updates_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("scatter", "X", 0, X_, false);
  auto Ids = CastPyHandleToVarBase("scatter", "Ids", 1, Ids_, false);
  auto Updates = CastPyHandleToVarBase("scatter", "Updates", 2, Updates_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("scatter", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Ids", {Ids}},{"Updates", {Updates}}};
    
    tracer->TraceOp("scatter", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_shard_index(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("shard_index", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("shard_index", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("shard_index", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_conj(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("conj", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("conj", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("conj", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_lstmp(const py::handle& Input_,const py::handle& Weight_,const py::handle& ProjWeight_,const py::handle& Bias_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("lstmp", "Input", 0, Input_, false);
  auto Weight = CastPyHandleToVarBase("lstmp", "Weight", 1, Weight_, false);
  auto ProjWeight = CastPyHandleToVarBase("lstmp", "ProjWeight", 2, ProjWeight_, false);
  auto Bias = CastPyHandleToVarBase("lstmp", "Bias", 3, Bias_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("lstmp", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Projection", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Cell", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"BatchGate", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"BatchCellPreAct", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"BatchHidden", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"Weight", {Weight}},{"ProjWeight", {ProjWeight}},{"Bias", {Bias}}};
    
    tracer->TraceOp("lstmp", ins, outs, attrs);
    return std::make_tuple(outs["Projection"][0],outs["Cell"][0],outs["BatchGate"][0],outs["BatchCellPreAct"][0],outs["BatchHidden"][0]); 
  }   
}

std::vector<std::shared_ptr<imperative::VarBase>> imperative_split(const py::handle& X_,size_t OutNum, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("split", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("split", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", ConstructDuplicableOutput(OutNum)}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("split", ins, outs, attrs);
    return outs["Out"]; 
  }   
}

std::tuple<std::vector<std::shared_ptr<imperative::VarBase>>,std::shared_ptr<imperative::VarBase>> imperative_run_program(const py::handle& X_,size_t OutNum, const py::args& args)
{
  
  auto X = CastPyHandleToVarBaseList("run_program", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("run_program", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", ConstructDuplicableOutput(OutNum)},{"OutScope", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", X}};
    
    tracer->TraceOp("run_program", ins, outs, attrs);
    return std::make_tuple(outs["Out"],outs["OutScope"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_stack(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBaseList("stack", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("stack", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Y", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", X}};
    
    tracer->TraceOp("stack", ins, outs, attrs);
    return outs["Y"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_strided_slice(const py::handle& Input_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("strided_slice", "Input", 0, Input_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("strided_slice", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}}};
    
    tracer->TraceOp("strided_slice", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::vector<std::shared_ptr<imperative::VarBase>> imperative_split_selected_rows(const py::handle& X_,size_t OutNum, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("split_selected_rows", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("split_selected_rows", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", ConstructDuplicableOutput(OutNum)}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("split_selected_rows", ins, outs, attrs);
    return outs["Out"]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_similarity_focus(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("similarity_focus", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("similarity_focus", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("similarity_focus", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_histogram(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("histogram", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("histogram", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("histogram", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_top_k(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("top_k", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("top_k", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Indices", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("top_k", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["Indices"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_fill_zeros_like(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fill_zeros_like", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fill_zeros_like", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("fill_zeros_like", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

void imperative_save_combine(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBaseList("save_combine", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("save_combine", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {};
    imperative::NameVarBaseMap ins = {{"X", X}};
    
    tracer->TraceOp("save_combine", ins, outs, attrs);
    return ; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sequence_reshape(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sequence_reshape", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sequence_reshape", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("sequence_reshape", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_auc(const py::handle& Predict_,const py::handle& Label_,const py::handle& StatPos_,const py::handle& StatNeg_, const py::args& args)
{
  
  auto Predict = CastPyHandleToVarBase("auc", "Predict", 0, Predict_, false);
  auto Label = CastPyHandleToVarBase("auc", "Label", 1, Label_, false);
  auto StatPos = CastPyHandleToVarBase("auc", "StatPos", 2, StatPos_, false);
  auto StatNeg = CastPyHandleToVarBase("auc", "StatNeg", 3, StatNeg_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("auc", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"AUC", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"StatPosOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"StatNegOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Predict", {Predict}},{"Label", {Label}},{"StatPos", {StatPos}},{"StatNeg", {StatNeg}}};
    
    tracer->TraceOp("auc", ins, outs, attrs);
    return std::make_tuple(outs["AUC"][0],outs["StatPosOut"][0],outs["StatNegOut"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_adagrad(const py::handle& Param_,const py::handle& Grad_,const py::handle& Moment_,const py::handle& LearningRate_, const py::args& args)
{
  
  auto Param = CastPyHandleToVarBase("adagrad", "Param", 0, Param_, false);
  auto Grad = CastPyHandleToVarBase("adagrad", "Grad", 1, Grad_, false);
  auto Moment = CastPyHandleToVarBase("adagrad", "Moment", 2, Moment_, false);
  auto LearningRate = CastPyHandleToVarBase("adagrad", "LearningRate", 3, LearningRate_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("adagrad", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"ParamOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"MomentOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Param", {Param}},{"Grad", {Grad}},{"Moment", {Moment}},{"LearningRate", {LearningRate}}};
    
    tracer->TraceOp("adagrad", ins, outs, attrs);
    return std::make_tuple(outs["ParamOut"][0],outs["MomentOut"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_fsp(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fsp", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("fsp", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fsp", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("fsp", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_tile(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("tile", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("tile", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("tile", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_flatten2(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("flatten2", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("flatten2", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"XShape", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("flatten2", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["XShape"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_fake_quantize_moving_average_abs_max(const py::handle& X_,const py::handle& InScale_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fake_quantize_moving_average_abs_max", "X", 0, X_, false);
  auto InScale = CastPyHandleToVarBase("fake_quantize_moving_average_abs_max", "InScale", 1, InScale_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fake_quantize_moving_average_abs_max", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"OutScale", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"InScale", {InScale}}};
    
    tracer->TraceOp("fake_quantize_moving_average_abs_max", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["OutScale"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_roll(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("roll", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("roll", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("roll", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_space_to_depth(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("space_to_depth", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("space_to_depth", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("space_to_depth", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_partial_concat(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBaseList("partial_concat", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("partial_concat", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", X}};
    
    tracer->TraceOp("partial_concat", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_flatten(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("flatten", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("flatten", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("flatten", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_spectral_norm(const py::handle& Weight_,const py::handle& U_,const py::handle& V_, const py::args& args)
{
  
  auto Weight = CastPyHandleToVarBase("spectral_norm", "Weight", 0, Weight_, false);
  auto U = CastPyHandleToVarBase("spectral_norm", "U", 1, U_, false);
  auto V = CastPyHandleToVarBase("spectral_norm", "V", 2, V_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("spectral_norm", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Weight", {Weight}},{"U", {U}},{"V", {V}}};
    
    tracer->TraceOp("spectral_norm", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_shuffle_batch(const py::handle& X_,const py::handle& Seed_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("shuffle_batch", "X", 0, X_, false);
  auto Seed = CastPyHandleToVarBase("shuffle_batch", "Seed", 1, Seed_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("shuffle_batch", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"ShuffleIdx", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SeedOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Seed", {Seed}}};
    
    tracer->TraceOp("shuffle_batch", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["ShuffleIdx"][0],outs["SeedOut"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_gather(const py::handle& X_,const py::handle& Index_,const py::handle& Axis_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("gather", "X", 0, X_, false);
  auto Index = CastPyHandleToVarBase("gather", "Index", 1, Index_, false);
  auto Axis = CastPyHandleToVarBase("gather", "Axis", 2, Axis_, true);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("gather", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Index", {Index}}};
    	
    if (Axis != nullptr) {	
      ins["Axis"] = {Axis};	
    }	

    tracer->TraceOp("gather", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_adamax(const py::handle& Param_,const py::handle& Grad_,const py::handle& LearningRate_,const py::handle& Moment_,const py::handle& InfNorm_,const py::handle& Beta1Pow_, const py::args& args)
{
  
  auto Param = CastPyHandleToVarBase("adamax", "Param", 0, Param_, false);
  auto Grad = CastPyHandleToVarBase("adamax", "Grad", 1, Grad_, false);
  auto LearningRate = CastPyHandleToVarBase("adamax", "LearningRate", 2, LearningRate_, false);
  auto Moment = CastPyHandleToVarBase("adamax", "Moment", 3, Moment_, false);
  auto InfNorm = CastPyHandleToVarBase("adamax", "InfNorm", 4, InfNorm_, false);
  auto Beta1Pow = CastPyHandleToVarBase("adamax", "Beta1Pow", 5, Beta1Pow_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("adamax", 6, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"ParamOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"MomentOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"InfNormOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Param", {Param}},{"Grad", {Grad}},{"LearningRate", {LearningRate}},{"Moment", {Moment}},{"InfNorm", {InfNorm}},{"Beta1Pow", {Beta1Pow}}};
    
    tracer->TraceOp("adamax", ins, outs, attrs);
    return std::make_tuple(outs["ParamOut"][0],outs["MomentOut"][0],outs["InfNormOut"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_softmax(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("softmax", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("softmax", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("softmax", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_trilinear_interp_v2(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("trilinear_interp_v2", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("trilinear_interp_v2", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("trilinear_interp_v2", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_reduce_any(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("reduce_any", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("reduce_any", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("reduce_any", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

void imperative_save(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("save", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("save", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("save", ins, outs, attrs);
    return ; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_equal(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("equal", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("equal", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("equal", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("equal", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_tril_triu(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("tril_triu", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("tril_triu", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("tril_triu", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_tree_conv(const py::handle& NodesVector_,const py::handle& EdgeSet_,const py::handle& Filter_, const py::args& args)
{
  
  auto NodesVector = CastPyHandleToVarBase("tree_conv", "NodesVector", 0, NodesVector_, false);
  auto EdgeSet = CastPyHandleToVarBase("tree_conv", "EdgeSet", 1, EdgeSet_, false);
  auto Filter = CastPyHandleToVarBase("tree_conv", "Filter", 2, Filter_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("tree_conv", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"NodesVector", {NodesVector}},{"EdgeSet", {EdgeSet}},{"Filter", {Filter}}};
    
    tracer->TraceOp("tree_conv", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_pad(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("pad", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("pad", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("pad", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_fusion_squared_mat_sub(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fusion_squared_mat_sub", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("fusion_squared_mat_sub", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fusion_squared_mat_sub", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"SquaredX", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SquaredY", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SquaredXY", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("fusion_squared_mat_sub", ins, outs, attrs);
    return std::make_tuple(outs["SquaredX"][0],outs["SquaredY"][0],outs["SquaredXY"][0],outs["Out"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_maxout(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("maxout", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("maxout", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("maxout", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_fake_dequantize_max_abs(const py::handle& X_,const py::handle& Scale_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fake_dequantize_max_abs", "X", 0, X_, false);
  auto Scale = CastPyHandleToVarBase("fake_dequantize_max_abs", "Scale", 1, Scale_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fake_dequantize_max_abs", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Scale", {Scale}}};
    
    tracer->TraceOp("fake_dequantize_max_abs", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_unique_with_counts(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("unique_with_counts", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("unique_with_counts", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Index", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Count", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("unique_with_counts", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["Index"][0],outs["Count"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_where_index(const py::handle& Condition_, const py::args& args)
{
  
  auto Condition = CastPyHandleToVarBase("where_index", "Condition", 0, Condition_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("where_index", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Condition", {Condition}}};
    
    tracer->TraceOp("where_index", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_truncated_gaussian_random(const py::args& args)
{
  
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("truncated_gaussian_random", 0, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {};
    
    tracer->TraceOp("truncated_gaussian_random", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_sequence_pad(const py::handle& X_,const py::handle& PadValue_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sequence_pad", "X", 0, X_, false);
  auto PadValue = CastPyHandleToVarBase("sequence_pad", "PadValue", 1, PadValue_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sequence_pad", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Length", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"PadValue", {PadValue}}};
    
    tracer->TraceOp("sequence_pad", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["Length"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_fake_channel_wise_quantize_dequantize_abs_max(const py::handle& X_,std::shared_ptr<imperative::VarBase>Out,std::shared_ptr<imperative::VarBase>OutScale, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fake_channel_wise_quantize_dequantize_abs_max", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fake_channel_wise_quantize_dequantize_abs_max", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {Out}},{"OutScale", {OutScale}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("fake_channel_wise_quantize_dequantize_abs_max", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["OutScale"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_spp(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("spp", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("spp", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("spp", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_sync_batch_norm(const py::handle& X_,const py::handle& Scale_,const py::handle& Bias_,const py::handle& Mean_,const py::handle& Variance_,std::shared_ptr<imperative::VarBase>MeanOut,std::shared_ptr<imperative::VarBase>VarianceOut, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sync_batch_norm", "X", 0, X_, false);
  auto Scale = CastPyHandleToVarBase("sync_batch_norm", "Scale", 1, Scale_, false);
  auto Bias = CastPyHandleToVarBase("sync_batch_norm", "Bias", 2, Bias_, false);
  auto Mean = CastPyHandleToVarBase("sync_batch_norm", "Mean", 3, Mean_, false);
  auto Variance = CastPyHandleToVarBase("sync_batch_norm", "Variance", 4, Variance_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sync_batch_norm", 7, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Y", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"MeanOut", {MeanOut}},{"VarianceOut", {VarianceOut}},{"SavedMean", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SavedVariance", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"ReserveSpace", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Scale", {Scale}},{"Bias", {Bias}},{"Mean", {Mean}},{"Variance", {Variance}}};
    
    tracer->TraceOp("sync_batch_norm", ins, outs, attrs);
    return std::make_tuple(outs["Y"][0],outs["MeanOut"][0],outs["VarianceOut"][0],outs["SavedMean"][0],outs["SavedVariance"][0],outs["ReserveSpace"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_generate_proposals_v2(const py::handle& Scores_,const py::handle& BboxDeltas_,const py::handle& ImShape_,const py::handle& Anchors_,const py::handle& Variances_, const py::args& args)
{
  
  auto Scores = CastPyHandleToVarBase("generate_proposals_v2", "Scores", 0, Scores_, false);
  auto BboxDeltas = CastPyHandleToVarBase("generate_proposals_v2", "BboxDeltas", 1, BboxDeltas_, false);
  auto ImShape = CastPyHandleToVarBase("generate_proposals_v2", "ImShape", 2, ImShape_, false);
  auto Anchors = CastPyHandleToVarBase("generate_proposals_v2", "Anchors", 3, Anchors_, false);
  auto Variances = CastPyHandleToVarBase("generate_proposals_v2", "Variances", 4, Variances_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("generate_proposals_v2", 5, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"RpnRois", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"RpnRoiProbs", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"RpnRoisNum", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Scores", {Scores}},{"BboxDeltas", {BboxDeltas}},{"ImShape", {ImShape}},{"Anchors", {Anchors}},{"Variances", {Variances}}};
    
    tracer->TraceOp("generate_proposals_v2", ins, outs, attrs);
    return std::make_tuple(outs["RpnRois"][0],outs["RpnRoiProbs"][0],outs["RpnRoisNum"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_randperm(const py::args& args)
{
  
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("randperm", 0, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {};
    
    tracer->TraceOp("randperm", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_set_value(const py::handle& Input_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("set_value", "Input", 0, Input_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("set_value", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}}};
    
    tracer->TraceOp("set_value", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_index_select(const py::handle& X_,const py::handle& Index_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("index_select", "X", 0, X_, false);
  auto Index = CastPyHandleToVarBase("index_select", "Index", 1, Index_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("index_select", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Index", {Index}}};
    
    tracer->TraceOp("index_select", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

void imperative_push_dense(const py::handle& Ids_, const py::args& args)
{
  
  auto Ids = CastPyHandleToVarBaseList("push_dense", "Ids", 0, Ids_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("push_dense", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {};
    imperative::NameVarBaseMap ins = {{"Ids", Ids}};
    
    tracer->TraceOp("push_dense", ins, outs, attrs);
    return ; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_cross_entropy(const py::handle& X_,const py::handle& Label_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("cross_entropy", "X", 0, X_, false);
  auto Label = CastPyHandleToVarBase("cross_entropy", "Label", 1, Label_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("cross_entropy", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Y", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Label", {Label}}};
    
    tracer->TraceOp("cross_entropy", ins, outs, attrs);
    return outs["Y"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_uniform_random(const py::args& args)
{
  
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("uniform_random", 0, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {};
    
    tracer->TraceOp("uniform_random", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_top_k_v2(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("top_k_v2", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("top_k_v2", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Indices", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("top_k_v2", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["Indices"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_bilinear_interp(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("bilinear_interp", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("bilinear_interp", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("bilinear_interp", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sequence_concat(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBaseList("sequence_concat", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sequence_concat", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", X}};
    
    tracer->TraceOp("sequence_concat", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_unsqueeze(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("unsqueeze", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("unsqueeze", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("unsqueeze", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_linspace(const py::handle& Start_,const py::handle& Stop_,const py::handle& Num_, const py::args& args)
{
  
  auto Start = CastPyHandleToVarBase("linspace", "Start", 0, Start_, false);
  auto Stop = CastPyHandleToVarBase("linspace", "Stop", 1, Stop_, false);
  auto Num = CastPyHandleToVarBase("linspace", "Num", 2, Num_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("linspace", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Start", {Start}},{"Stop", {Stop}},{"Num", {Num}}};
    
    tracer->TraceOp("linspace", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_fc(const py::handle& Input_,const py::handle& W_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("fc", "Input", 0, Input_, false);
  auto W = CastPyHandleToVarBase("fc", "W", 1, W_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fc", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"W", {W}}};
    
    tracer->TraceOp("fc", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_slice(const py::handle& Input_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("slice", "Input", 0, Input_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("slice", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}}};
    
    tracer->TraceOp("slice", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_tdm_sampler(const py::handle& X_,const py::handle& Travel_,const py::handle& Layer_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("tdm_sampler", "X", 0, X_, false);
  auto Travel = CastPyHandleToVarBase("tdm_sampler", "Travel", 1, Travel_, false);
  auto Layer = CastPyHandleToVarBase("tdm_sampler", "Layer", 2, Layer_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("tdm_sampler", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Mask", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Travel", {Travel}},{"Layer", {Layer}}};
    
    tracer->TraceOp("tdm_sampler", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["Mask"][0]); 
  }   
}

std::vector<std::shared_ptr<imperative::VarBase>> imperative_unstack(const py::handle& X_,size_t YNum, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("unstack", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("unstack", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Y", ConstructDuplicableOutput(YNum)}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("unstack", ins, outs, attrs);
    return outs["Y"]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_where(const py::handle& Condition_,const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto Condition = CastPyHandleToVarBase("where", "Condition", 0, Condition_, false);
  auto X = CastPyHandleToVarBase("where", "X", 1, X_, false);
  auto Y = CastPyHandleToVarBase("where", "Y", 2, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("where", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Condition", {Condition}},{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("where", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_seed(const py::args& args)
{
  
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("seed", 0, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {};
    
    tracer->TraceOp("seed", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_unique(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("unique", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("unique", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Index", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Indices", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Counts", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("unique", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["Index"][0],outs["Indices"][0],outs["Counts"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_uniform_random_batch_size_like(const py::handle& Input_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("uniform_random_batch_size_like", "Input", 0, Input_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("uniform_random_batch_size_like", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}}};
    
    tracer->TraceOp("uniform_random_batch_size_like", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sgd(const py::handle& Param_,const py::handle& LearningRate_,const py::handle& Grad_,std::shared_ptr<imperative::VarBase>ParamOut, const py::args& args)
{
  
  auto Param = CastPyHandleToVarBase("sgd", "Param", 0, Param_, false);
  auto LearningRate = CastPyHandleToVarBase("sgd", "LearningRate", 1, LearningRate_, false);
  auto Grad = CastPyHandleToVarBase("sgd", "Grad", 2, Grad_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sgd", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"ParamOut", {ParamOut}}};
    imperative::NameVarBaseMap ins = {{"Param", {Param}},{"LearningRate", {LearningRate}},{"Grad", {Grad}}};
    
    tracer->TraceOp("sgd", ins, outs, attrs);
    return outs["ParamOut"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_data_norm(const py::handle& X_,const py::handle& BatchSize_,const py::handle& BatchSum_,const py::handle& BatchSquareSum_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("data_norm", "X", 0, X_, false);
  auto BatchSize = CastPyHandleToVarBase("data_norm", "BatchSize", 1, BatchSize_, false);
  auto BatchSum = CastPyHandleToVarBase("data_norm", "BatchSum", 2, BatchSum_, false);
  auto BatchSquareSum = CastPyHandleToVarBase("data_norm", "BatchSquareSum", 3, BatchSquareSum_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("data_norm", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Y", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Means", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Scales", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"BatchSize", {BatchSize}},{"BatchSum", {BatchSum}},{"BatchSquareSum", {BatchSquareSum}}};
    
    tracer->TraceOp("data_norm", ins, outs, attrs);
    return std::make_tuple(outs["Y"][0],outs["Means"][0],outs["Scales"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_warpctc(const py::handle& Logits_,const py::handle& Label_,const py::handle& LogitsLength_,const py::handle& LabelLength_, const py::args& args)
{
  
  auto Logits = CastPyHandleToVarBase("warpctc", "Logits", 0, Logits_, false);
  auto Label = CastPyHandleToVarBase("warpctc", "Label", 1, Label_, false);
  auto LogitsLength = CastPyHandleToVarBase("warpctc", "LogitsLength", 2, LogitsLength_, true);
  auto LabelLength = CastPyHandleToVarBase("warpctc", "LabelLength", 3, LabelLength_, true);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("warpctc", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"WarpCTCGrad", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Loss", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Logits", {Logits}},{"Label", {Label}}};
    	
    if (LogitsLength != nullptr) {	
      ins["LogitsLength"] = {LogitsLength};	
    }	
	
    if (LabelLength != nullptr) {	
      ins["LabelLength"] = {LabelLength};	
    }	

    tracer->TraceOp("warpctc", ins, outs, attrs);
    return std::make_tuple(outs["WarpCTCGrad"][0],outs["Loss"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_kldiv_loss(const py::handle& X_,const py::handle& Target_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("kldiv_loss", "X", 0, X_, false);
  auto Target = CastPyHandleToVarBase("kldiv_loss", "Target", 1, Target_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("kldiv_loss", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Loss", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Target", {Target}}};
    
    tracer->TraceOp("kldiv_loss", ins, outs, attrs);
    return outs["Loss"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_lookup_table_dequant(const py::handle& W_,const py::handle& Ids_, const py::args& args)
{
  
  auto W = CastPyHandleToVarBase("lookup_table_dequant", "W", 0, W_, false);
  auto Ids = CastPyHandleToVarBase("lookup_table_dequant", "Ids", 1, Ids_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("lookup_table_dequant", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"W", {W}},{"Ids", {Ids}}};
    
    tracer->TraceOp("lookup_table_dequant", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_smooth_l1_loss(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("smooth_l1_loss", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("smooth_l1_loss", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("smooth_l1_loss", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Diff", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("smooth_l1_loss", ins, outs, attrs);
    return std::make_tuple(outs["Diff"][0],outs["Out"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_reshape(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("reshape", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("reshape", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("reshape", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_tdm_child(const py::handle& X_,const py::handle& TreeInfo_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("tdm_child", "X", 0, X_, false);
  auto TreeInfo = CastPyHandleToVarBase("tdm_child", "TreeInfo", 1, TreeInfo_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("tdm_child", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Child", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"LeafMask", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"TreeInfo", {TreeInfo}}};
    
    tracer->TraceOp("tdm_child", ins, outs, attrs);
    return std::make_tuple(outs["Child"][0],outs["LeafMask"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_stanh(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("stanh", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("stanh", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("stanh", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_gru(const py::handle& Input_,const py::handle& Weight_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("gru", "Input", 0, Input_, false);
  auto Weight = CastPyHandleToVarBase("gru", "Weight", 1, Weight_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("gru", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"BatchGate", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"BatchResetHiddenPrev", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"BatchHidden", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Hidden", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"Weight", {Weight}}};
    
    tracer->TraceOp("gru", ins, outs, attrs);
    return std::make_tuple(outs["BatchGate"][0],outs["BatchResetHiddenPrev"][0],outs["BatchHidden"][0],outs["Hidden"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_log2(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("log2", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("log2", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("log2", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_nce(const py::handle& Input_,const py::handle& Label_,const py::handle& Weight_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("nce", "Input", 0, Input_, false);
  auto Label = CastPyHandleToVarBase("nce", "Label", 1, Label_, false);
  auto Weight = CastPyHandleToVarBase("nce", "Weight", 2, Weight_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("nce", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Cost", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SampleLogits", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SampleLabels", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"Label", {Label}},{"Weight", {Weight}}};
    
    tracer->TraceOp("nce", ins, outs, attrs);
    return std::make_tuple(outs["Cost"][0],outs["SampleLogits"][0],outs["SampleLabels"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_label_smooth(const py::handle& X_,const py::handle& PriorDist_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("label_smooth", "X", 0, X_, false);
  auto PriorDist = CastPyHandleToVarBase("label_smooth", "PriorDist", 1, PriorDist_, true);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("label_smooth", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    	
    if (PriorDist != nullptr) {	
      ins["PriorDist"] = {PriorDist};	
    }	

    tracer->TraceOp("label_smooth", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sigmoid_cross_entropy_with_logits(const py::handle& X_,const py::handle& Label_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sigmoid_cross_entropy_with_logits", "X", 0, X_, false);
  auto Label = CastPyHandleToVarBase("sigmoid_cross_entropy_with_logits", "Label", 1, Label_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sigmoid_cross_entropy_with_logits", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Label", {Label}}};
    
    tracer->TraceOp("sigmoid_cross_entropy_with_logits", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_temporal_shift(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("temporal_shift", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("temporal_shift", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("temporal_shift", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_pad3d(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("pad3d", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("pad3d", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("pad3d", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_cudnn_lstm(const py::handle& Input_,const py::handle& InitH_,const py::handle& InitC_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("cudnn_lstm", "Input", 0, Input_, false);
  auto InitH = CastPyHandleToVarBase("cudnn_lstm", "InitH", 1, InitH_, false);
  auto InitC = CastPyHandleToVarBase("cudnn_lstm", "InitC", 2, InitC_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("cudnn_lstm", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Reserve", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"StateOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"LastH", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"LastC", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"InitH", {InitH}},{"InitC", {InitC}}};
    
    tracer->TraceOp("cudnn_lstm", ins, outs, attrs);
    return std::make_tuple(outs["Reserve"][0],outs["StateOut"][0],outs["Out"][0],outs["LastH"][0],outs["LastC"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_flip(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("flip", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("flip", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("flip", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_rank_loss(const py::handle& Label_,const py::handle& Left_,const py::handle& Right_, const py::args& args)
{
  
  auto Label = CastPyHandleToVarBase("rank_loss", "Label", 0, Label_, false);
  auto Left = CastPyHandleToVarBase("rank_loss", "Left", 1, Left_, false);
  auto Right = CastPyHandleToVarBase("rank_loss", "Right", 2, Right_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("rank_loss", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Label", {Label}},{"Left", {Left}},{"Right", {Right}}};
    
    tracer->TraceOp("rank_loss", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_bernoulli(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("bernoulli", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("bernoulli", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("bernoulli", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_scatter_nd_add(const py::handle& X_,const py::handle& Index_,const py::handle& Updates_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("scatter_nd_add", "X", 0, X_, false);
  auto Index = CastPyHandleToVarBase("scatter_nd_add", "Index", 1, Index_, false);
  auto Updates = CastPyHandleToVarBase("scatter_nd_add", "Updates", 2, Updates_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("scatter_nd_add", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Index", {Index}},{"Updates", {Updates}}};
    
    tracer->TraceOp("scatter_nd_add", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_depthwise_conv2d_transpose(const py::handle& Input_,const py::handle& Filter_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("depthwise_conv2d_transpose", "Input", 0, Input_, false);
  auto Filter = CastPyHandleToVarBase("depthwise_conv2d_transpose", "Filter", 1, Filter_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("depthwise_conv2d_transpose", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Output", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"Filter", {Filter}}};
    
    tracer->TraceOp("depthwise_conv2d_transpose", ins, outs, attrs);
    return outs["Output"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_batch_fc(const py::handle& Input_,const py::handle& W_,const py::handle& Bias_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("batch_fc", "Input", 0, Input_, false);
  auto W = CastPyHandleToVarBase("batch_fc", "W", 1, W_, false);
  auto Bias = CastPyHandleToVarBase("batch_fc", "Bias", 2, Bias_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("batch_fc", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"W", {W}},{"Bias", {Bias}}};
    
    tracer->TraceOp("batch_fc", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_selu(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("selu", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("selu", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("selu", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_reduce_mean(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("reduce_mean", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("reduce_mean", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("reduce_mean", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_isinf_v2(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("isinf_v2", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("isinf_v2", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("isinf_v2", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_shape(const py::handle& Input_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("shape", "Input", 0, Input_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("shape", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}}};
    
    tracer->TraceOp("shape", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_logsigmoid(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("logsigmoid", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("logsigmoid", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("logsigmoid", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sampling_id(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sampling_id", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sampling_id", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("sampling_id", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_unpool(const py::handle& X_,const py::handle& Indices_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("unpool", "X", 0, X_, false);
  auto Indices = CastPyHandleToVarBase("unpool", "Indices", 1, Indices_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("unpool", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Indices", {Indices}}};
    
    tracer->TraceOp("unpool", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_segment_pool(const py::handle& X_,const py::handle& SegmentIds_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("segment_pool", "X", 0, X_, false);
  auto SegmentIds = CastPyHandleToVarBase("segment_pool", "SegmentIds", 1, SegmentIds_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("segment_pool", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SummedIds", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"SegmentIds", {SegmentIds}}};
    
    tracer->TraceOp("segment_pool", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["SummedIds"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_lookup_table(const py::handle& W_,const py::handle& Ids_, const py::args& args)
{
  
  auto W = CastPyHandleToVarBase("lookup_table", "W", 0, W_, false);
  auto Ids = CastPyHandleToVarBase("lookup_table", "Ids", 1, Ids_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("lookup_table", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"W", {W}},{"Ids", {Ids}}};
    
    tracer->TraceOp("lookup_table", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::vector<std::shared_ptr<imperative::VarBase>> imperative_pull_box_sparse(const py::handle& Ids_,size_t OutNum, const py::args& args)
{
  
  auto Ids = CastPyHandleToVarBaseList("pull_box_sparse", "Ids", 0, Ids_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("pull_box_sparse", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", ConstructDuplicableOutput(OutNum)}};
    imperative::NameVarBaseMap ins = {{"Ids", Ids}};
    
    tracer->TraceOp("pull_box_sparse", ins, outs, attrs);
    return outs["Out"]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_real(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("real", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("real", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("real", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_bicubic_interp(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("bicubic_interp", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("bicubic_interp", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("bicubic_interp", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_sample_logits(const py::handle& Logits_,const py::handle& Labels_, const py::args& args)
{
  
  auto Logits = CastPyHandleToVarBase("sample_logits", "Logits", 0, Logits_, false);
  auto Labels = CastPyHandleToVarBase("sample_logits", "Labels", 1, Labels_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sample_logits", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Samples", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Probabilities", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"LogitsDim", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"LabelsDim", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SampledLogits", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SampledLabels", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Logits", {Logits}},{"Labels", {Labels}}};
    
    tracer->TraceOp("sample_logits", ins, outs, attrs);
    return std::make_tuple(outs["Samples"][0],outs["Probabilities"][0],outs["LogitsDim"][0],outs["LabelsDim"][0],outs["SampledLogits"][0],outs["SampledLabels"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_sequence_topk_avg_pooling(const py::handle& X_,const py::handle& ROW_,const py::handle& COLUMN_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sequence_topk_avg_pooling", "X", 0, X_, false);
  auto ROW = CastPyHandleToVarBase("sequence_topk_avg_pooling", "ROW", 1, ROW_, false);
  auto COLUMN = CastPyHandleToVarBase("sequence_topk_avg_pooling", "COLUMN", 2, COLUMN_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sequence_topk_avg_pooling", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"pos", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"ROW", {ROW}},{"COLUMN", {COLUMN}}};
    
    tracer->TraceOp("sequence_topk_avg_pooling", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["pos"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_acos(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("acos", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("acos", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("acos", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::vector<std::shared_ptr<imperative::VarBase>>> imperative_rnn(const py::handle& Input_,const py::handle& PreState_,const py::handle& WeightList_,size_t StateNum, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("rnn", "Input", 0, Input_, false);
  auto PreState = CastPyHandleToVarBaseList("rnn", "PreState", 1, PreState_, false);
  auto WeightList = CastPyHandleToVarBaseList("rnn", "WeightList", 2, WeightList_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("rnn", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Reserve", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"State", ConstructDuplicableOutput(StateNum)}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"PreState", PreState},{"WeightList", WeightList}};
    
    tracer->TraceOp("rnn", ins, outs, attrs);
    return std::make_tuple(outs["Reserve"][0],outs["Out"][0],outs["State"]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_fake_quantize_dequantize_moving_average_abs_max(const py::handle& X_,const py::handle& InScale_,const py::handle& InAccum_,const py::handle& InState_,std::shared_ptr<imperative::VarBase>Out,std::shared_ptr<imperative::VarBase>OutScale,std::shared_ptr<imperative::VarBase>OutState,std::shared_ptr<imperative::VarBase>OutAccum, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fake_quantize_dequantize_moving_average_abs_max", "X", 0, X_, false);
  auto InScale = CastPyHandleToVarBase("fake_quantize_dequantize_moving_average_abs_max", "InScale", 1, InScale_, false);
  auto InAccum = CastPyHandleToVarBase("fake_quantize_dequantize_moving_average_abs_max", "InAccum", 2, InAccum_, true);
  auto InState = CastPyHandleToVarBase("fake_quantize_dequantize_moving_average_abs_max", "InState", 3, InState_, true);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fake_quantize_dequantize_moving_average_abs_max", 8, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {Out}},{"OutScale", {OutScale}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"InScale", {InScale}}};
    	
    if (InAccum != nullptr) {	
      ins["InAccum"] = {InAccum};	
    }	
	
    if (InState != nullptr) {	
      ins["InState"] = {InState};	
    }	

    outs["OutState"] = {OutState};

    outs["OutAccum"] = {OutAccum};

    tracer->TraceOp("fake_quantize_dequantize_moving_average_abs_max", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["OutScale"][0],outs["OutState"][0],outs["OutAccum"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_fusion_seqpool_cvm_concat(const py::handle& X_,const py::handle& CVM_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBaseList("fusion_seqpool_cvm_concat", "X", 0, X_, false);
  auto CVM = CastPyHandleToVarBase("fusion_seqpool_cvm_concat", "CVM", 1, CVM_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fusion_seqpool_cvm_concat", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", X},{"CVM", {CVM}}};
    
    tracer->TraceOp("fusion_seqpool_cvm_concat", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sign(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sign", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sign", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("sign", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_expand_as(const py::handle& X_,const py::handle& target_tensor_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("expand_as", "X", 0, X_, false);
  auto target_tensor = CastPyHandleToVarBase("expand_as", "target_tensor", 1, target_tensor_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("expand_as", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"target_tensor", {target_tensor}}};
    
    tracer->TraceOp("expand_as", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_bicubic_interp_v2(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("bicubic_interp_v2", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("bicubic_interp_v2", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("bicubic_interp_v2", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_isnan_v2(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("isnan_v2", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("isnan_v2", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("isnan_v2", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_arg_max(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("arg_max", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("arg_max", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("arg_max", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_roi_pool(const py::handle& X_,const py::handle& ROIs_,const py::handle& RoisNum_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("roi_pool", "X", 0, X_, false);
  auto ROIs = CastPyHandleToVarBase("roi_pool", "ROIs", 1, ROIs_, false);
  auto RoisNum = CastPyHandleToVarBase("roi_pool", "RoisNum", 2, RoisNum_, true);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("roi_pool", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Argmax", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"ROIs", {ROIs}}};
    	
    if (RoisNum != nullptr) {	
      ins["RoisNum"] = {RoisNum};	
    }	

    tracer->TraceOp("roi_pool", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["Argmax"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_roi_align(const py::handle& X_,const py::handle& ROIs_,const py::handle& RoisNum_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("roi_align", "X", 0, X_, false);
  auto ROIs = CastPyHandleToVarBase("roi_align", "ROIs", 1, ROIs_, false);
  auto RoisNum = CastPyHandleToVarBase("roi_align", "RoisNum", 2, RoisNum_, true);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("roi_align", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"ROIs", {ROIs}}};
    	
    if (RoisNum != nullptr) {	
      ins["RoisNum"] = {RoisNum};	
    }	

    tracer->TraceOp("roi_align", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_unsqueeze2(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("unsqueeze2", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("unsqueeze2", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"XShape", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("unsqueeze2", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["XShape"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_random_crop(const py::handle& X_,const py::handle& Seed_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("random_crop", "X", 0, X_, false);
  auto Seed = CastPyHandleToVarBase("random_crop", "Seed", 1, Seed_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("random_crop", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SeedOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Seed", {Seed}}};
    
    tracer->TraceOp("random_crop", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["SeedOut"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_diag_embed(const py::handle& Input_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("diag_embed", "Input", 0, Input_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("diag_embed", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}}};
    
    tracer->TraceOp("diag_embed", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_squared_l2_norm(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("squared_l2_norm", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("squared_l2_norm", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("squared_l2_norm", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_fusion_seqpool_concat(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBaseList("fusion_seqpool_concat", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fusion_seqpool_concat", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", X}};
    
    tracer->TraceOp("fusion_seqpool_concat", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_gaussian_random_batch_size_like(const py::handle& Input_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("gaussian_random_batch_size_like", "Input", 0, Input_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("gaussian_random_batch_size_like", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}}};
    
    tracer->TraceOp("gaussian_random_batch_size_like", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_beam_search(const py::handle& pre_ids_,const py::handle& pre_scores_,const py::handle& scores_, const py::args& args)
{
  
  auto pre_ids = CastPyHandleToVarBase("beam_search", "pre_ids", 0, pre_ids_, false);
  auto pre_scores = CastPyHandleToVarBase("beam_search", "pre_scores", 1, pre_scores_, false);
  auto scores = CastPyHandleToVarBase("beam_search", "scores", 2, scores_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("beam_search", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"selected_ids", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"selected_scores", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"pre_ids", {pre_ids}},{"pre_scores", {pre_scores}},{"scores", {scores}}};
    
    tracer->TraceOp("beam_search", ins, outs, attrs);
    return std::make_tuple(outs["selected_ids"][0],outs["selected_scores"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_reverse(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("reverse", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("reverse", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("reverse", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_l1_norm(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("l1_norm", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("l1_norm", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("l1_norm", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_expand(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("expand", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("expand", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("expand", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_gru_unit(const py::handle& Input_,const py::handle& HiddenPrev_,const py::handle& Weight_,const py::handle& Bias_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("gru_unit", "Input", 0, Input_, false);
  auto HiddenPrev = CastPyHandleToVarBase("gru_unit", "HiddenPrev", 1, HiddenPrev_, false);
  auto Weight = CastPyHandleToVarBase("gru_unit", "Weight", 2, Weight_, false);
  auto Bias = CastPyHandleToVarBase("gru_unit", "Bias", 3, Bias_, true);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("gru_unit", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Gate", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"ResetHiddenPrev", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Hidden", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"HiddenPrev", {HiddenPrev}},{"Weight", {Weight}}};
    	
    if (Bias != nullptr) {	
      ins["Bias"] = {Bias};	
    }	

    tracer->TraceOp("gru_unit", ins, outs, attrs);
    return std::make_tuple(outs["Gate"][0],outs["ResetHiddenPrev"][0],outs["Hidden"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_grad_add(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("grad_add", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("grad_add", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("grad_add", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("grad_add", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_rank_attention(const py::handle& X_,const py::handle& RankOffset_,const py::handle& RankParam_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("rank_attention", "X", 0, X_, false);
  auto RankOffset = CastPyHandleToVarBase("rank_attention", "RankOffset", 1, RankOffset_, false);
  auto RankParam = CastPyHandleToVarBase("rank_attention", "RankParam", 2, RankParam_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("rank_attention", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"RankOffset", {RankOffset}},{"RankParam", {RankParam}}};
    
    tracer->TraceOp("rank_attention", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_range(const py::handle& Start_,const py::handle& End_,const py::handle& Step_, const py::args& args)
{
  
  auto Start = CastPyHandleToVarBase("range", "Start", 0, Start_, false);
  auto End = CastPyHandleToVarBase("range", "End", 1, End_, false);
  auto Step = CastPyHandleToVarBase("range", "Step", 2, Step_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("range", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Start", {Start}},{"End", {End}},{"Step", {Step}}};
    
    tracer->TraceOp("range", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_one_hot(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("one_hot", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("one_hot", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("one_hot", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::vector<std::shared_ptr<imperative::VarBase>>,std::shared_ptr<imperative::VarBase>> imperative_fusion_repeated_fc_relu(const py::handle& X_,const py::handle& W_,const py::handle& Bias_,size_t ReluOutNum, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fusion_repeated_fc_relu", "X", 0, X_, false);
  auto W = CastPyHandleToVarBaseList("fusion_repeated_fc_relu", "W", 1, W_, false);
  auto Bias = CastPyHandleToVarBaseList("fusion_repeated_fc_relu", "Bias", 2, Bias_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fusion_repeated_fc_relu", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"ReluOut", ConstructDuplicableOutput(ReluOutNum)},{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"W", W},{"Bias", Bias}};
    
    tracer->TraceOp("fusion_repeated_fc_relu", ins, outs, attrs);
    return std::make_tuple(outs["ReluOut"],outs["Out"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_randint(const py::args& args)
{
  
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("randint", 0, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {};
    
    tracer->TraceOp("randint", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_gather_nd(const py::handle& X_,const py::handle& Index_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("gather_nd", "X", 0, X_, false);
  auto Index = CastPyHandleToVarBase("gather_nd", "Index", 1, Index_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("gather_nd", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Index", {Index}}};
    
    tracer->TraceOp("gather_nd", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_squared_l2_distance(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("squared_l2_distance", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("squared_l2_distance", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("squared_l2_distance", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"sub_result", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("squared_l2_distance", ins, outs, attrs);
    return std::make_tuple(outs["sub_result"][0],outs["Out"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_yolo_box(const py::handle& X_,const py::handle& ImgSize_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("yolo_box", "X", 0, X_, false);
  auto ImgSize = CastPyHandleToVarBase("yolo_box", "ImgSize", 1, ImgSize_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("yolo_box", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Boxes", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Scores", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"ImgSize", {ImgSize}}};
    
    tracer->TraceOp("yolo_box", ins, outs, attrs);
    return std::make_tuple(outs["Boxes"][0],outs["Scores"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_transpose2(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("transpose2", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("transpose2", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"XShape", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("transpose2", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["XShape"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_empty(const py::args& args)
{
  
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("empty", 0, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {};
    
    tracer->TraceOp("empty", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_elementwise_min(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("elementwise_min", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("elementwise_min", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("elementwise_min", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("elementwise_min", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::vector<std::shared_ptr<imperative::VarBase>>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_update_loss_scaling(const py::handle& X_,const py::handle& FoundInfinite_,const py::handle& PrevLossScaling_,const py::handle& InGoodSteps_,const py::handle& InBadSteps_,std::vector<std::shared_ptr<imperative::VarBase>>Out,std::shared_ptr<imperative::VarBase>LossScaling,std::shared_ptr<imperative::VarBase>OutGoodSteps,std::shared_ptr<imperative::VarBase>OutBadSteps, const py::args& args)
{
  
  auto X = CastPyHandleToVarBaseList("update_loss_scaling", "X", 0, X_, false);
  auto FoundInfinite = CastPyHandleToVarBase("update_loss_scaling", "FoundInfinite", 1, FoundInfinite_, false);
  auto PrevLossScaling = CastPyHandleToVarBase("update_loss_scaling", "PrevLossScaling", 2, PrevLossScaling_, false);
  auto InGoodSteps = CastPyHandleToVarBase("update_loss_scaling", "InGoodSteps", 3, InGoodSteps_, false);
  auto InBadSteps = CastPyHandleToVarBase("update_loss_scaling", "InBadSteps", 4, InBadSteps_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("update_loss_scaling", 9, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", Out},{"LossScaling", {LossScaling}},{"OutGoodSteps", {OutGoodSteps}},{"OutBadSteps", {OutBadSteps}}};
    imperative::NameVarBaseMap ins = {{"X", X},{"FoundInfinite", {FoundInfinite}},{"PrevLossScaling", {PrevLossScaling}},{"InGoodSteps", {InGoodSteps}},{"InBadSteps", {InBadSteps}}};
    
    tracer->TraceOp("update_loss_scaling", ins, outs, attrs);
    return std::make_tuple(outs["Out"],outs["LossScaling"][0],outs["OutGoodSteps"][0],outs["OutBadSteps"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_pyramid_hash(const py::handle& X_,const py::handle& W_,const py::handle& WhiteList_,const py::handle& BlackList_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("pyramid_hash", "X", 0, X_, false);
  auto W = CastPyHandleToVarBase("pyramid_hash", "W", 1, W_, false);
  auto WhiteList = CastPyHandleToVarBase("pyramid_hash", "WhiteList", 2, WhiteList_, false);
  auto BlackList = CastPyHandleToVarBase("pyramid_hash", "BlackList", 3, BlackList_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("pyramid_hash", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"DropPos", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"X_Temp_Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"W", {W}},{"WhiteList", {WhiteList}},{"BlackList", {BlackList}}};
    
    tracer->TraceOp("pyramid_hash", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["DropPos"][0],outs["X_Temp_Out"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_accuracy(const py::handle& Out_,const py::handle& Indices_,const py::handle& Label_,std::shared_ptr<imperative::VarBase>Correct,std::shared_ptr<imperative::VarBase>Total, const py::args& args)
{
  
  auto Out = CastPyHandleToVarBase("accuracy", "Out", 0, Out_, false);
  auto Indices = CastPyHandleToVarBase("accuracy", "Indices", 1, Indices_, false);
  auto Label = CastPyHandleToVarBase("accuracy", "Label", 2, Label_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("accuracy", 5, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Accuracy", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Correct", {Correct}},{"Total", {Total}}};
    imperative::NameVarBaseMap ins = {{"Out", {Out}},{"Indices", {Indices}},{"Label", {Label}}};
    
    tracer->TraceOp("accuracy", ins, outs, attrs);
    return std::make_tuple(outs["Accuracy"][0],outs["Correct"][0],outs["Total"][0]); 
  }   
}

std::vector<std::shared_ptr<imperative::VarBase>> imperative_pull_sparse_v2(const py::handle& Ids_,const py::handle& W_,size_t OutNum, const py::args& args)
{
  
  auto Ids = CastPyHandleToVarBaseList("pull_sparse_v2", "Ids", 0, Ids_, false);
  auto W = CastPyHandleToVarBaseList("pull_sparse_v2", "W", 1, W_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("pull_sparse_v2", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", ConstructDuplicableOutput(OutNum)}};
    imperative::NameVarBaseMap ins = {{"Ids", Ids},{"W", W}};
    
    tracer->TraceOp("pull_sparse_v2", ins, outs, attrs);
    return outs["Out"]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_logsumexp(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("logsumexp", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("logsumexp", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("logsumexp", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::vector<std::shared_ptr<imperative::VarBase>>,std::vector<std::shared_ptr<imperative::VarBase>>> imperative_pull_box_extended_sparse(const py::handle& Ids_,size_t OutNum,size_t OutExtendNum, const py::args& args)
{
  
  auto Ids = CastPyHandleToVarBaseList("pull_box_extended_sparse", "Ids", 0, Ids_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("pull_box_extended_sparse", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", ConstructDuplicableOutput(OutNum)},{"OutExtend", ConstructDuplicableOutput(OutExtendNum)}};
    imperative::NameVarBaseMap ins = {{"Ids", Ids}};
    
    tracer->TraceOp("pull_box_extended_sparse", ins, outs, attrs);
    return std::make_tuple(outs["Out"],outs["OutExtend"]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_instance_norm(const py::handle& X_,const py::handle& Scale_,const py::handle& Bias_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("instance_norm", "X", 0, X_, false);
  auto Scale = CastPyHandleToVarBase("instance_norm", "Scale", 1, Scale_, true);
  auto Bias = CastPyHandleToVarBase("instance_norm", "Bias", 2, Bias_, true);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("instance_norm", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Y", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SavedMean", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SavedVariance", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    	
    if (Scale != nullptr) {	
      ins["Scale"] = {Scale};	
    }	
	
    if (Bias != nullptr) {	
      ins["Bias"] = {Bias};	
    }	

    tracer->TraceOp("instance_norm", ins, outs, attrs);
    return std::make_tuple(outs["Y"][0],outs["SavedMean"][0],outs["SavedVariance"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_psroi_pool(const py::handle& X_,const py::handle& ROIs_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("psroi_pool", "X", 0, X_, false);
  auto ROIs = CastPyHandleToVarBase("psroi_pool", "ROIs", 1, ROIs_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("psroi_pool", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"ROIs", {ROIs}}};
    
    tracer->TraceOp("psroi_pool", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_iou_similarity(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("iou_similarity", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("iou_similarity", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("iou_similarity", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("iou_similarity", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_linear_interp(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("linear_interp", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("linear_interp", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("linear_interp", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_max_pool3d_with_index(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("max_pool3d_with_index", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("max_pool3d_with_index", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Mask", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("max_pool3d_with_index", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["Mask"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sum(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBaseList("sum", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sum", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", X}};
    
    tracer->TraceOp("sum", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_reshape2(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("reshape2", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("reshape2", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"XShape", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("reshape2", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["XShape"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_flatten_contiguous_range(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("flatten_contiguous_range", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("flatten_contiguous_range", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"XShape", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("flatten_contiguous_range", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["XShape"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_fake_quantize_range_abs_max(const py::handle& X_,const py::handle& InScale_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fake_quantize_range_abs_max", "X", 0, X_, false);
  auto InScale = CastPyHandleToVarBase("fake_quantize_range_abs_max", "InScale", 1, InScale_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fake_quantize_range_abs_max", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"OutScale", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"InScale", {InScale}}};
    
    tracer->TraceOp("fake_quantize_range_abs_max", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["OutScale"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_deformable_psroi_pooling(const py::handle& Input_,const py::handle& ROIs_,const py::handle& Trans_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("deformable_psroi_pooling", "Input", 0, Input_, false);
  auto ROIs = CastPyHandleToVarBase("deformable_psroi_pooling", "ROIs", 1, ROIs_, false);
  auto Trans = CastPyHandleToVarBase("deformable_psroi_pooling", "Trans", 2, Trans_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("deformable_psroi_pooling", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"TopCount", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Output", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"ROIs", {ROIs}},{"Trans", {Trans}}};
    
    tracer->TraceOp("deformable_psroi_pooling", ins, outs, attrs);
    return std::make_tuple(outs["TopCount"][0],outs["Output"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_attention_lstm(const py::handle& X_,const py::handle& C0_,const py::handle& AttentionWeight_,const py::handle& LSTMWeight_,const py::handle& LSTMBias_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("attention_lstm", "X", 0, X_, false);
  auto C0 = CastPyHandleToVarBase("attention_lstm", "C0", 1, C0_, false);
  auto AttentionWeight = CastPyHandleToVarBase("attention_lstm", "AttentionWeight", 2, AttentionWeight_, false);
  auto LSTMWeight = CastPyHandleToVarBase("attention_lstm", "LSTMWeight", 3, LSTMWeight_, false);
  auto LSTMBias = CastPyHandleToVarBase("attention_lstm", "LSTMBias", 4, LSTMBias_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("attention_lstm", 5, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Hidden", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Cell", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"AttentionedX", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"AttentionFCOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"LSTMX", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"LSTMOUT", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"C0", {C0}},{"AttentionWeight", {AttentionWeight}},{"LSTMWeight", {LSTMWeight}},{"LSTMBias", {LSTMBias}}};
    
    tracer->TraceOp("attention_lstm", ins, outs, attrs);
    return std::make_tuple(outs["Hidden"][0],outs["Cell"][0],outs["AttentionedX"][0],outs["AttentionFCOut"][0],outs["LSTMX"][0],outs["LSTMOUT"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_fill_zeros_like2(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fill_zeros_like2", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fill_zeros_like2", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("fill_zeros_like2", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_fill(const py::args& args)
{
  
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fill", 0, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {};
    
    tracer->TraceOp("fill", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_diag(const py::handle& Diagonal_, const py::args& args)
{
  
  auto Diagonal = CastPyHandleToVarBase("diag", "Diagonal", 0, Diagonal_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("diag", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Diagonal", {Diagonal}}};
    
    tracer->TraceOp("diag", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_tanh_shrink(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("tanh_shrink", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("tanh_shrink", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("tanh_shrink", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_fill_any_like(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fill_any_like", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fill_any_like", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("fill_any_like", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_proximal_adagrad(const py::handle& Param_,const py::handle& Moment_,const py::handle& Grad_,const py::handle& LearningRate_, const py::args& args)
{
  
  auto Param = CastPyHandleToVarBase("proximal_adagrad", "Param", 0, Param_, false);
  auto Moment = CastPyHandleToVarBase("proximal_adagrad", "Moment", 1, Moment_, false);
  auto Grad = CastPyHandleToVarBase("proximal_adagrad", "Grad", 2, Grad_, false);
  auto LearningRate = CastPyHandleToVarBase("proximal_adagrad", "LearningRate", 3, LearningRate_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("proximal_adagrad", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"ParamOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"MomentOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Param", {Param}},{"Moment", {Moment}},{"Grad", {Grad}},{"LearningRate", {LearningRate}}};
    
    tracer->TraceOp("proximal_adagrad", ins, outs, attrs);
    return std::make_tuple(outs["ParamOut"][0],outs["MomentOut"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_fake_quantize_dequantize_abs_max(const py::handle& X_,std::shared_ptr<imperative::VarBase>Out,std::shared_ptr<imperative::VarBase>OutScale, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fake_quantize_dequantize_abs_max", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fake_quantize_dequantize_abs_max", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {Out}},{"OutScale", {OutScale}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("fake_quantize_dequantize_abs_max", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["OutScale"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_ncclAllReduce(const py::handle& X_,const py::handle& Communicator_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("ncclAllReduce", "X", 0, X_, false);
  auto Communicator = CastPyHandleToVarBase("ncclAllReduce", "Communicator", 1, Communicator_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("ncclAllReduce", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Communicator", {Communicator}}};
    
    tracer->TraceOp("ncclAllReduce", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_fake_channel_wise_quantize_abs_max(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fake_channel_wise_quantize_abs_max", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fake_channel_wise_quantize_abs_max", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"OutScale", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("fake_channel_wise_quantize_abs_max", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["OutScale"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_density_prior_box(const py::handle& Input_,const py::handle& Image_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("density_prior_box", "Input", 0, Input_, false);
  auto Image = CastPyHandleToVarBase("density_prior_box", "Image", 1, Image_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("density_prior_box", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Boxes", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Variances", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"Image", {Image}}};
    
    tracer->TraceOp("density_prior_box", ins, outs, attrs);
    return std::make_tuple(outs["Boxes"][0],outs["Variances"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_moving_average_abs_max_scale(const py::handle& X_,const py::handle& InAccum_,const py::handle& InState_,std::shared_ptr<imperative::VarBase>OutScale,std::shared_ptr<imperative::VarBase>OutState,std::shared_ptr<imperative::VarBase>OutAccum, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("moving_average_abs_max_scale", "X", 0, X_, false);
  auto InAccum = CastPyHandleToVarBase("moving_average_abs_max_scale", "InAccum", 1, InAccum_, true);
  auto InState = CastPyHandleToVarBase("moving_average_abs_max_scale", "InState", 2, InState_, true);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("moving_average_abs_max_scale", 6, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"OutScale", {OutScale}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    	
    if (InAccum != nullptr) {	
      ins["InAccum"] = {InAccum};	
    }	
	
    if (InState != nullptr) {	
      ins["InState"] = {InState};	
    }	

    outs["OutState"] = {OutState};

    outs["OutAccum"] = {OutAccum};

    tracer->TraceOp("moving_average_abs_max_scale", ins, outs, attrs);
    return std::make_tuple(outs["OutScale"][0],outs["OutState"][0],outs["OutAccum"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_fake_channel_wise_dequantize_max_abs(const py::handle& X_,const py::handle& Scales_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fake_channel_wise_dequantize_max_abs", "X", 0, X_, false);
  auto Scales = CastPyHandleToVarBaseList("fake_channel_wise_dequantize_max_abs", "Scales", 1, Scales_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fake_channel_wise_dequantize_max_abs", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Scales", Scales}};
    
    tracer->TraceOp("fake_channel_wise_dequantize_max_abs", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_chunk_eval(const py::handle& Inference_,const py::handle& Label_, const py::args& args)
{
  
  auto Inference = CastPyHandleToVarBase("chunk_eval", "Inference", 0, Inference_, false);
  auto Label = CastPyHandleToVarBase("chunk_eval", "Label", 1, Label_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("chunk_eval", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Precision", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Recall", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"F1-Score", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"NumInferChunks", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"NumLabelChunks", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"NumCorrectChunks", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Inference", {Inference}},{"Label", {Label}}};
    
    tracer->TraceOp("chunk_eval", ins, outs, attrs);
    return std::make_tuple(outs["Precision"][0],outs["Recall"][0],outs["F1-Score"][0],outs["NumInferChunks"][0],outs["NumLabelChunks"][0],outs["NumCorrectChunks"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_erf(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("erf", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("erf", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("erf", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_dropout(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("dropout", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("dropout", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Mask", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("dropout", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["Mask"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_diag_v2(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("diag_v2", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("diag_v2", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("diag_v2", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_cholesky(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("cholesky", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("cholesky", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("cholesky", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_fill_constant_batch_size_like(const py::handle& Input_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("fill_constant_batch_size_like", "Input", 0, Input_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fill_constant_batch_size_like", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}}};
    
    tracer->TraceOp("fill_constant_batch_size_like", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_expand_as_v2(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("expand_as_v2", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("expand_as_v2", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("expand_as_v2", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_dequantize_abs_max(const py::handle& X_,const py::handle& Scale_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("dequantize_abs_max", "X", 0, X_, false);
  auto Scale = CastPyHandleToVarBase("dequantize_abs_max", "Scale", 1, Scale_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("dequantize_abs_max", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Scale", {Scale}}};
    
    tracer->TraceOp("dequantize_abs_max", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_deformable_conv(const py::handle& Input_,const py::handle& Offset_,const py::handle& Mask_,const py::handle& Filter_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("deformable_conv", "Input", 0, Input_, false);
  auto Offset = CastPyHandleToVarBase("deformable_conv", "Offset", 1, Offset_, false);
  auto Mask = CastPyHandleToVarBase("deformable_conv", "Mask", 2, Mask_, false);
  auto Filter = CastPyHandleToVarBase("deformable_conv", "Filter", 3, Filter_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("deformable_conv", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Output", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"Offset", {Offset}},{"Mask", {Mask}},{"Filter", {Filter}}};
    
    tracer->TraceOp("deformable_conv", ins, outs, attrs);
    return outs["Output"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sigmoid(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sigmoid", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sigmoid", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("sigmoid", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_log1p(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("log1p", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("log1p", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("log1p", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_cumsum(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("cumsum", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("cumsum", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("cumsum", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_ctc_align(const py::handle& Input_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("ctc_align", "Input", 0, Input_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("ctc_align", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Output", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}}};
    
    tracer->TraceOp("ctc_align", ins, outs, attrs);
    return outs["Output"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_imag(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("imag", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("imag", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("imag", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_transpose(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("transpose", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("transpose", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("transpose", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_roi_perspective_transform(const py::handle& X_,const py::handle& ROIs_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("roi_perspective_transform", "X", 0, X_, false);
  auto ROIs = CastPyHandleToVarBase("roi_perspective_transform", "ROIs", 1, ROIs_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("roi_perspective_transform", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Mask", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"TransformMatrix", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Out2InIdx", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Out2InWeights", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"ROIs", {ROIs}}};
    
    tracer->TraceOp("roi_perspective_transform", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["Mask"][0],outs["TransformMatrix"][0],outs["Out2InIdx"][0],outs["Out2InWeights"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_crop_tensor(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("crop_tensor", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("crop_tensor", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("crop_tensor", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sequence_unpad(const py::handle& X_,const py::handle& Length_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sequence_unpad", "X", 0, X_, false);
  auto Length = CastPyHandleToVarBase("sequence_unpad", "Length", 1, Length_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sequence_unpad", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Length", {Length}}};
    
    tracer->TraceOp("sequence_unpad", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_crop(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("crop", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("crop", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("crop", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_log(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("log", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("log", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("log", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_conv3d_transpose(const py::handle& Input_,const py::handle& Filter_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("conv3d_transpose", "Input", 0, Input_, false);
  auto Filter = CastPyHandleToVarBase("conv3d_transpose", "Filter", 1, Filter_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("conv3d_transpose", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Output", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"Filter", {Filter}}};
    
    tracer->TraceOp("conv3d_transpose", ins, outs, attrs);
    return outs["Output"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_conv2d_fusion(const py::handle& Input_,const py::handle& Filter_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("conv2d_fusion", "Input", 0, Input_, false);
  auto Filter = CastPyHandleToVarBase("conv2d_fusion", "Filter", 1, Filter_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("conv2d_fusion", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Output", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"Filter", {Filter}}};
    
    tracer->TraceOp("conv2d_fusion", ins, outs, attrs);
    return outs["Output"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_cos_sim(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("cos_sim", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("cos_sim", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("cos_sim", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"XNorm", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"YNorm", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("cos_sim", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["XNorm"][0],outs["YNorm"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_cvm(const py::handle& X_,const py::handle& CVM_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("cvm", "X", 0, X_, false);
  auto CVM = CastPyHandleToVarBase("cvm", "CVM", 1, CVM_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("cvm", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Y", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"CVM", {CVM}}};
    
    tracer->TraceOp("cvm", ins, outs, attrs);
    return outs["Y"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_fused_bn_add_activation(const py::handle& X_,const py::handle& Z_,const py::handle& Scale_,const py::handle& Bias_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fused_bn_add_activation", "X", 0, X_, false);
  auto Z = CastPyHandleToVarBase("fused_bn_add_activation", "Z", 1, Z_, false);
  auto Scale = CastPyHandleToVarBase("fused_bn_add_activation", "Scale", 2, Scale_, false);
  auto Bias = CastPyHandleToVarBase("fused_bn_add_activation", "Bias", 3, Bias_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fused_bn_add_activation", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Y", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"MeanOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"VarianceOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SavedMean", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SavedVariance", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"ReserveSpace", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Z", {Z}},{"Scale", {Scale}},{"Bias", {Bias}}};
    
    tracer->TraceOp("fused_bn_add_activation", ins, outs, attrs);
    return std::make_tuple(outs["Y"][0],outs["MeanOut"][0],outs["VarianceOut"][0],outs["SavedMean"][0],outs["SavedVariance"][0],outs["ReserveSpace"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_conv_shift(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("conv_shift", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("conv_shift", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("conv_shift", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("conv_shift", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_scale(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("scale", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("scale", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("scale", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_conv2d(const py::handle& Input_,const py::handle& Filter_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("conv2d", "Input", 0, Input_, false);
  auto Filter = CastPyHandleToVarBase("conv2d", "Filter", 1, Filter_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("conv2d", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Output", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"Filter", {Filter}}};
    
    tracer->TraceOp("conv2d", ins, outs, attrs);
    return outs["Output"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_depthwise_conv2d(const py::handle& Input_,const py::handle& Filter_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("depthwise_conv2d", "Input", 0, Input_, false);
  auto Filter = CastPyHandleToVarBase("depthwise_conv2d", "Filter", 1, Filter_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("depthwise_conv2d", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Output", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"Filter", {Filter}}};
    
    tracer->TraceOp("depthwise_conv2d", ins, outs, attrs);
    return outs["Output"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_reduce_prod(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("reduce_prod", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("reduce_prod", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("reduce_prod", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_add_position_encoding(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("add_position_encoding", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("add_position_encoding", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("add_position_encoding", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_reduce_min(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("reduce_min", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("reduce_min", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("reduce_min", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_conv3d(const py::handle& Input_,const py::handle& Filter_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("conv3d", "Input", 0, Input_, false);
  auto Filter = CastPyHandleToVarBase("conv3d", "Filter", 1, Filter_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("conv3d", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Output", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"Filter", {Filter}}};
    
    tracer->TraceOp("conv3d", ins, outs, attrs);
    return outs["Output"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_squeeze2(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("squeeze2", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("squeeze2", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"XShape", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("squeeze2", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["XShape"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_concat(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBaseList("concat", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("concat", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", X}};
    
    tracer->TraceOp("concat", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_clip(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("clip", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("clip", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("clip", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_cast(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("cast", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("cast", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("cast", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::vector<std::shared_ptr<imperative::VarBase>>,std::shared_ptr<imperative::VarBase>,std::vector<std::shared_ptr<imperative::VarBase>>> imperative_distribute_fpn_proposals(const py::handle& FpnRois_,const py::handle& RoisNum_,size_t MultiFpnRoisNum,size_t MultiLevelRoIsNumNum, const py::args& args)
{
  
  auto FpnRois = CastPyHandleToVarBase("distribute_fpn_proposals", "FpnRois", 0, FpnRois_, false);
  auto RoisNum = CastPyHandleToVarBase("distribute_fpn_proposals", "RoisNum", 1, RoisNum_, true);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("distribute_fpn_proposals", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"MultiFpnRois", ConstructDuplicableOutput(MultiFpnRoisNum)},{"RestoreIndex", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"MultiLevelRoIsNum", ConstructDuplicableOutput(MultiLevelRoIsNumNum)}};
    imperative::NameVarBaseMap ins = {{"FpnRois", {FpnRois}}};
    	
    if (RoisNum != nullptr) {	
      ins["RoisNum"] = {RoisNum};	
    }	

    tracer->TraceOp("distribute_fpn_proposals", ins, outs, attrs);
    return std::make_tuple(outs["MultiFpnRois"],outs["RestoreIndex"][0],outs["MultiLevelRoIsNum"]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_bmm(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("bmm", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("bmm", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("bmm", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("bmm", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_bilinear_tensor_product(const py::handle& X_,const py::handle& Y_,const py::handle& Weight_,const py::handle& Bias_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("bilinear_tensor_product", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("bilinear_tensor_product", "Y", 1, Y_, false);
  auto Weight = CastPyHandleToVarBase("bilinear_tensor_product", "Weight", 2, Weight_, false);
  auto Bias = CastPyHandleToVarBase("bilinear_tensor_product", "Bias", 3, Bias_, true);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("bilinear_tensor_product", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}},{"Weight", {Weight}}};
    	
    if (Bias != nullptr) {	
      ins["Bias"] = {Bias};	
    }	

    tracer->TraceOp("bilinear_tensor_product", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_elementwise_pow(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("elementwise_pow", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("elementwise_pow", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("elementwise_pow", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("elementwise_pow", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_ftrl(const py::handle& Param_,const py::handle& SquaredAccumulator_,const py::handle& LinearAccumulator_,const py::handle& Grad_,const py::handle& LearningRate_, const py::args& args)
{
  
  auto Param = CastPyHandleToVarBase("ftrl", "Param", 0, Param_, false);
  auto SquaredAccumulator = CastPyHandleToVarBase("ftrl", "SquaredAccumulator", 1, SquaredAccumulator_, false);
  auto LinearAccumulator = CastPyHandleToVarBase("ftrl", "LinearAccumulator", 2, LinearAccumulator_, false);
  auto Grad = CastPyHandleToVarBase("ftrl", "Grad", 3, Grad_, false);
  auto LearningRate = CastPyHandleToVarBase("ftrl", "LearningRate", 4, LearningRate_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("ftrl", 5, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"ParamOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SquaredAccumOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"LinearAccumOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Param", {Param}},{"SquaredAccumulator", {SquaredAccumulator}},{"LinearAccumulator", {LinearAccumulator}},{"Grad", {Grad}},{"LearningRate", {LearningRate}}};
    
    tracer->TraceOp("ftrl", ins, outs, attrs);
    return std::make_tuple(outs["ParamOut"][0],outs["SquaredAccumOut"][0],outs["LinearAccumOut"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_kron(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("kron", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("kron", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("kron", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("kron", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_prelu(const py::handle& X_,const py::handle& Alpha_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("prelu", "X", 0, X_, false);
  auto Alpha = CastPyHandleToVarBase("prelu", "Alpha", 1, Alpha_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("prelu", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Alpha", {Alpha}}};
    
    tracer->TraceOp("prelu", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_bce_loss(const py::handle& X_,const py::handle& Label_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("bce_loss", "X", 0, X_, false);
  auto Label = CastPyHandleToVarBase("bce_loss", "Label", 1, Label_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("bce_loss", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Label", {Label}}};
    
    tracer->TraceOp("bce_loss", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_generate_proposals(const py::handle& Scores_,const py::handle& BboxDeltas_,const py::handle& ImInfo_,const py::handle& Anchors_,const py::handle& Variances_, const py::args& args)
{
  
  auto Scores = CastPyHandleToVarBase("generate_proposals", "Scores", 0, Scores_, false);
  auto BboxDeltas = CastPyHandleToVarBase("generate_proposals", "BboxDeltas", 1, BboxDeltas_, false);
  auto ImInfo = CastPyHandleToVarBase("generate_proposals", "ImInfo", 2, ImInfo_, false);
  auto Anchors = CastPyHandleToVarBase("generate_proposals", "Anchors", 3, Anchors_, false);
  auto Variances = CastPyHandleToVarBase("generate_proposals", "Variances", 4, Variances_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("generate_proposals", 5, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"RpnRois", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"RpnRoiProbs", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"RpnRoisNum", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Scores", {Scores}},{"BboxDeltas", {BboxDeltas}},{"ImInfo", {ImInfo}},{"Anchors", {Anchors}},{"Variances", {Variances}}};
    
    tracer->TraceOp("generate_proposals", ins, outs, attrs);
    return std::make_tuple(outs["RpnRois"][0],outs["RpnRoiProbs"][0],outs["RpnRoisNum"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_batch_norm(const py::handle& X_,const py::handle& Scale_,const py::handle& Bias_,const py::handle& Mean_,const py::handle& Variance_,std::shared_ptr<imperative::VarBase>MeanOut,std::shared_ptr<imperative::VarBase>VarianceOut, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("batch_norm", "X", 0, X_, false);
  auto Scale = CastPyHandleToVarBase("batch_norm", "Scale", 1, Scale_, false);
  auto Bias = CastPyHandleToVarBase("batch_norm", "Bias", 2, Bias_, false);
  auto Mean = CastPyHandleToVarBase("batch_norm", "Mean", 3, Mean_, false);
  auto Variance = CastPyHandleToVarBase("batch_norm", "Variance", 4, Variance_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("batch_norm", 7, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Y", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"MeanOut", {MeanOut}},{"VarianceOut", {VarianceOut}},{"SavedMean", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SavedVariance", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"ReserveSpace", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Scale", {Scale}},{"Bias", {Bias}},{"Mean", {Mean}},{"Variance", {Variance}}};
    
    tracer->TraceOp("batch_norm", ins, outs, attrs);
    return std::make_tuple(outs["Y"][0],outs["MeanOut"][0],outs["VarianceOut"][0],outs["SavedMean"][0],outs["SavedVariance"][0],outs["ReserveSpace"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_assign_value(const py::args& args)
{
  
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("assign_value", 0, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {};
    
    tracer->TraceOp("assign_value", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_cross_entropy2(const py::handle& X_,const py::handle& Label_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("cross_entropy2", "X", 0, X_, false);
  auto Label = CastPyHandleToVarBase("cross_entropy2", "Label", 1, Label_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("cross_entropy2", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Y", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"XShape", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"MatchX", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Label", {Label}}};
    
    tracer->TraceOp("cross_entropy2", ins, outs, attrs);
    return std::make_tuple(outs["Y"][0],outs["XShape"][0],outs["MatchX"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_assign(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("assign", "X", 0, X_, true);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("assign", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {};
    	
    if (X != nullptr) {	
      ins["X"] = {X};	
    }	

    tracer->TraceOp("assign", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_arg_min(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("arg_min", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("arg_min", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("arg_min", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_group_norm(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("group_norm", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("group_norm", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Y", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Mean", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Variance", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("group_norm", ins, outs, attrs);
    return std::make_tuple(outs["Y"][0],outs["Mean"][0],outs["Variance"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_brelu(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("brelu", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("brelu", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("brelu", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_is_empty(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("is_empty", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("is_empty", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("is_empty", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_allclose(const py::handle& Input_,const py::handle& Other_,const py::handle& Rtol_,const py::handle& Atol_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("allclose", "Input", 0, Input_, false);
  auto Other = CastPyHandleToVarBase("allclose", "Other", 1, Other_, false);
  auto Rtol = CastPyHandleToVarBase("allclose", "Rtol", 2, Rtol_, false);
  auto Atol = CastPyHandleToVarBase("allclose", "Atol", 3, Atol_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("allclose", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"Other", {Other}},{"Rtol", {Rtol}},{"Atol", {Atol}}};
    
    tracer->TraceOp("allclose", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_affine_grid(const py::handle& Theta_, const py::args& args)
{
  
  auto Theta = CastPyHandleToVarBase("affine_grid", "Theta", 0, Theta_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("affine_grid", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Output", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Theta", {Theta}}};
    
    tracer->TraceOp("affine_grid", ins, outs, attrs);
    return outs["Output"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_affine_channel(const py::handle& X_,const py::handle& Scale_,const py::handle& Bias_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("affine_channel", "X", 0, X_, false);
  auto Scale = CastPyHandleToVarBase("affine_channel", "Scale", 1, Scale_, false);
  auto Bias = CastPyHandleToVarBase("affine_channel", "Bias", 2, Bias_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("affine_channel", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Scale", {Scale}},{"Bias", {Bias}}};
    
    tracer->TraceOp("affine_channel", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_addmm(const py::handle& Input_,const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("addmm", "Input", 0, Input_, false);
  auto X = CastPyHandleToVarBase("addmm", "X", 1, X_, false);
  auto Y = CastPyHandleToVarBase("addmm", "Y", 2, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("addmm", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("addmm", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_fused_fc_elementwise_layernorm(const py::handle& X_,const py::handle& W_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fused_fc_elementwise_layernorm", "X", 0, X_, false);
  auto W = CastPyHandleToVarBase("fused_fc_elementwise_layernorm", "W", 1, W_, false);
  auto Y = CastPyHandleToVarBase("fused_fc_elementwise_layernorm", "Y", 2, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fused_fc_elementwise_layernorm", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"W", {W}},{"Y", {Y}}};
    
    tracer->TraceOp("fused_fc_elementwise_layernorm", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_tanh(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("tanh", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("tanh", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("tanh", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_retinanet_detection_output(const py::handle& BBoxes_,const py::handle& Scores_,const py::handle& Anchors_,const py::handle& ImInfo_, const py::args& args)
{
  
  auto BBoxes = CastPyHandleToVarBaseList("retinanet_detection_output", "BBoxes", 0, BBoxes_, false);
  auto Scores = CastPyHandleToVarBaseList("retinanet_detection_output", "Scores", 1, Scores_, false);
  auto Anchors = CastPyHandleToVarBaseList("retinanet_detection_output", "Anchors", 2, Anchors_, false);
  auto ImInfo = CastPyHandleToVarBase("retinanet_detection_output", "ImInfo", 3, ImInfo_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("retinanet_detection_output", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"BBoxes", BBoxes},{"Scores", Scores},{"Anchors", Anchors},{"ImInfo", {ImInfo}}};
    
    tracer->TraceOp("retinanet_detection_output", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_prroi_pool(const py::handle& X_,const py::handle& ROIs_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("prroi_pool", "X", 0, X_, false);
  auto ROIs = CastPyHandleToVarBase("prroi_pool", "ROIs", 1, ROIs_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("prroi_pool", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"ROIs", {ROIs}}};
    
    tracer->TraceOp("prroi_pool", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_atan(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("atan", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("atan", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("atan", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_softshrink(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("softshrink", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("softshrink", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("softshrink", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_softplus(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("softplus", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("softplus", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("softplus", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_ceil(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("ceil", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("ceil", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("ceil", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_floor(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("floor", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("floor", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("floor", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_exp(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("exp", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("exp", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("exp", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_cos(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("cos", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("cos", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("cos", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_tan(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("tan", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("tan", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("tan", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_collect_fpn_proposals(const py::handle& MultiLevelRois_,const py::handle& MultiLevelScores_,const py::handle& MultiLevelRoIsNum_, const py::args& args)
{
  
  auto MultiLevelRois = CastPyHandleToVarBaseList("collect_fpn_proposals", "MultiLevelRois", 0, MultiLevelRois_, false);
  auto MultiLevelScores = CastPyHandleToVarBaseList("collect_fpn_proposals", "MultiLevelScores", 1, MultiLevelScores_, false);
  auto MultiLevelRoIsNum = CastPyHandleToVarBaseList("collect_fpn_proposals", "MultiLevelRoIsNum", 2, MultiLevelRoIsNum_, true);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("collect_fpn_proposals", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"FpnRois", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"RoisNum", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"MultiLevelRois", MultiLevelRois},{"MultiLevelScores", MultiLevelScores}};
    	
    if (MultiLevelRoIsNum.size() != 0) {
      ins["MultiLevelRoIsNum"] = MultiLevelRoIsNum;	
    }	

    tracer->TraceOp("collect_fpn_proposals", ins, outs, attrs);
    return std::make_tuple(outs["FpnRois"][0],outs["RoisNum"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_shuffle_channel(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("shuffle_channel", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("shuffle_channel", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("shuffle_channel", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sequence_conv(const py::handle& X_,const py::handle& Filter_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sequence_conv", "X", 0, X_, false);
  auto Filter = CastPyHandleToVarBase("sequence_conv", "Filter", 1, Filter_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sequence_conv", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Filter", {Filter}}};
    
    tracer->TraceOp("sequence_conv", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sin(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sin", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sin", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("sin", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_edit_distance(const py::handle& Hyps_,const py::handle& Refs_, const py::args& args)
{
  
  auto Hyps = CastPyHandleToVarBase("edit_distance", "Hyps", 0, Hyps_, false);
  auto Refs = CastPyHandleToVarBase("edit_distance", "Refs", 1, Refs_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("edit_distance", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"SequenceNum", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Hyps", {Hyps}},{"Refs", {Refs}}};
    
    tracer->TraceOp("edit_distance", ins, outs, attrs);
    return std::make_tuple(outs["SequenceNum"][0],outs["Out"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_cosh(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("cosh", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("cosh", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("cosh", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_reciprocal(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("reciprocal", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("reciprocal", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("reciprocal", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_round(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("round", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("round", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("round", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_soft_relu(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("soft_relu", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("soft_relu", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("soft_relu", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_bpr_loss(const py::handle& X_,const py::handle& Label_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("bpr_loss", "X", 0, X_, false);
  auto Label = CastPyHandleToVarBase("bpr_loss", "Label", 1, Label_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("bpr_loss", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Y", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Label", {Label}}};
    
    tracer->TraceOp("bpr_loss", ins, outs, attrs);
    return outs["Y"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_softsign(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("softsign", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("softsign", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("softsign", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_trace(const py::handle& Input_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("trace", "Input", 0, Input_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("trace", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}}};
    
    tracer->TraceOp("trace", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_adam(const py::handle& Param_,const py::handle& Grad_,const py::handle& LearningRate_,const py::handle& Moment1_,const py::handle& Moment2_,const py::handle& Beta1Pow_,const py::handle& Beta2Pow_,std::shared_ptr<imperative::VarBase>ParamOut,std::shared_ptr<imperative::VarBase>Moment1Out,std::shared_ptr<imperative::VarBase>Moment2Out,std::shared_ptr<imperative::VarBase>Beta1PowOut,std::shared_ptr<imperative::VarBase>Beta2PowOut, const py::args& args)
{
  
  auto Param = CastPyHandleToVarBase("adam", "Param", 0, Param_, false);
  auto Grad = CastPyHandleToVarBase("adam", "Grad", 1, Grad_, false);
  auto LearningRate = CastPyHandleToVarBase("adam", "LearningRate", 2, LearningRate_, false);
  auto Moment1 = CastPyHandleToVarBase("adam", "Moment1", 3, Moment1_, false);
  auto Moment2 = CastPyHandleToVarBase("adam", "Moment2", 4, Moment2_, false);
  auto Beta1Pow = CastPyHandleToVarBase("adam", "Beta1Pow", 5, Beta1Pow_, false);
  auto Beta2Pow = CastPyHandleToVarBase("adam", "Beta2Pow", 6, Beta2Pow_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("adam", 12, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"ParamOut", {ParamOut}},{"Moment1Out", {Moment1Out}},{"Moment2Out", {Moment2Out}},{"Beta1PowOut", {Beta1PowOut}},{"Beta2PowOut", {Beta2PowOut}}};
    imperative::NameVarBaseMap ins = {{"Param", {Param}},{"Grad", {Grad}},{"LearningRate", {LearningRate}},{"Moment1", {Moment1}},{"Moment2", {Moment2}},{"Beta1Pow", {Beta1Pow}},{"Beta2Pow", {Beta2Pow}}};
    
    tracer->TraceOp("adam", ins, outs, attrs);
    return std::make_tuple(outs["ParamOut"][0],outs["Moment1Out"][0],outs["Moment2Out"][0],outs["Beta1PowOut"][0],outs["Beta2PowOut"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_elementwise_sub(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("elementwise_sub", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("elementwise_sub", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("elementwise_sub", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("elementwise_sub", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_relu6(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("relu6", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("relu6", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("relu6", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_hard_sigmoid(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("hard_sigmoid", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("hard_sigmoid", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("hard_sigmoid", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_pad_constant_like(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("pad_constant_like", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("pad_constant_like", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("pad_constant_like", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("pad_constant_like", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_swish(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("swish", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("swish", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("swish", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_hard_swish(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("hard_swish", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("hard_swish", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("hard_swish", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_relu(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("relu", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("relu", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("relu", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_precision_recall(const py::handle& MaxProbs_,const py::handle& Indices_,const py::handle& Labels_, const py::args& args)
{
  
  auto MaxProbs = CastPyHandleToVarBase("precision_recall", "MaxProbs", 0, MaxProbs_, false);
  auto Indices = CastPyHandleToVarBase("precision_recall", "Indices", 1, Indices_, false);
  auto Labels = CastPyHandleToVarBase("precision_recall", "Labels", 2, Labels_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("precision_recall", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"BatchMetrics", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"AccumMetrics", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"AccumStatesInfo", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"MaxProbs", {MaxProbs}},{"Indices", {Indices}},{"Labels", {Labels}}};
    
    tracer->TraceOp("precision_recall", ins, outs, attrs);
    return std::make_tuple(outs["BatchMetrics"][0],outs["AccumMetrics"][0],outs["AccumStatesInfo"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_leaky_relu(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("leaky_relu", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("leaky_relu", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("leaky_relu", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_unfold(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("unfold", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("unfold", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Y", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("unfold", ins, outs, attrs);
    return outs["Y"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sqrt(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sqrt", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sqrt", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("sqrt", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_rsqrt(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("rsqrt", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("rsqrt", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("rsqrt", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_elementwise_mod(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("elementwise_mod", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("elementwise_mod", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("elementwise_mod", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("elementwise_mod", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_fake_quantize_abs_max(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fake_quantize_abs_max", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fake_quantize_abs_max", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"OutScale", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("fake_quantize_abs_max", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["OutScale"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_pow(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("pow", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("pow", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("pow", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_square(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("square", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("square", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("square", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_abs(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("abs", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("abs", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("abs", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::vector<std::shared_ptr<imperative::VarBase>>,std::shared_ptr<imperative::VarBase>> imperative_coalesce_tensor(const py::handle& Input_,size_t OutputNum, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBaseList("coalesce_tensor", "Input", 0, Input_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("coalesce_tensor", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Output", ConstructDuplicableOutput(OutputNum)},{"FusedOutput", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", Input}};
    
    tracer->TraceOp("coalesce_tensor", ins, outs, attrs);
    return std::make_tuple(outs["Output"],outs["FusedOutput"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_row_conv(const py::handle& X_,const py::handle& Filter_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("row_conv", "X", 0, X_, false);
  auto Filter = CastPyHandleToVarBase("row_conv", "Filter", 1, Filter_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("row_conv", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Filter", {Filter}}};
    
    tracer->TraceOp("row_conv", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sequence_reverse(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sequence_reverse", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sequence_reverse", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Y", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("sequence_reverse", ins, outs, attrs);
    return outs["Y"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_ncclBcast(const py::handle& X_,const py::handle& Communicator_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("ncclBcast", "X", 0, X_, false);
  auto Communicator = CastPyHandleToVarBase("ncclBcast", "Communicator", 1, Communicator_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("ncclBcast", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Communicator", {Communicator}}};
    
    tracer->TraceOp("ncclBcast", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_fusion_gru(const py::handle& X_,const py::handle& WeightX_,const py::handle& WeightH_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fusion_gru", "X", 0, X_, false);
  auto WeightX = CastPyHandleToVarBase("fusion_gru", "WeightX", 1, WeightX_, false);
  auto WeightH = CastPyHandleToVarBase("fusion_gru", "WeightH", 2, WeightH_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fusion_gru", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"ReorderedH0", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"XX", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"BatchedInput", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"BatchedOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Hidden", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"WeightX", {WeightX}},{"WeightH", {WeightH}}};
    
    tracer->TraceOp("fusion_gru", ins, outs, attrs);
    return std::make_tuple(outs["ReorderedH0"][0],outs["XX"][0],outs["BatchedInput"][0],outs["BatchedOut"][0],outs["Hidden"][0]); 
  }   
}

std::tuple<std::vector<std::shared_ptr<imperative::VarBase>>,std::shared_ptr<imperative::VarBase>> imperative_check_finite_and_unscale(const py::handle& X_,const py::handle& Scale_,std::vector<std::shared_ptr<imperative::VarBase>>Out,std::shared_ptr<imperative::VarBase>FoundInfinite, const py::args& args)
{
  
  auto X = CastPyHandleToVarBaseList("check_finite_and_unscale", "X", 0, X_, false);
  auto Scale = CastPyHandleToVarBase("check_finite_and_unscale", "Scale", 1, Scale_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("check_finite_and_unscale", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", Out},{"FoundInfinite", {FoundInfinite}}};
    imperative::NameVarBaseMap ins = {{"X", X},{"Scale", {Scale}}};
    
    tracer->TraceOp("check_finite_and_unscale", ins, outs, attrs);
    return std::make_tuple(outs["Out"],outs["FoundInfinite"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sequence_softmax(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sequence_softmax", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sequence_softmax", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("sequence_softmax", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sequence_slice(const py::handle& X_,const py::handle& Offset_,const py::handle& Length_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sequence_slice", "X", 0, X_, false);
  auto Offset = CastPyHandleToVarBase("sequence_slice", "Offset", 1, Offset_, false);
  auto Length = CastPyHandleToVarBase("sequence_slice", "Length", 2, Length_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sequence_slice", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Offset", {Offset}},{"Length", {Length}}};
    
    tracer->TraceOp("sequence_slice", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_sequence_pool(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sequence_pool", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sequence_pool", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"MaxIndex", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("sequence_pool", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["MaxIndex"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_deformable_conv_v1(const py::handle& Input_,const py::handle& Offset_,const py::handle& Filter_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("deformable_conv_v1", "Input", 0, Input_, false);
  auto Offset = CastPyHandleToVarBase("deformable_conv_v1", "Offset", 1, Offset_, false);
  auto Filter = CastPyHandleToVarBase("deformable_conv_v1", "Filter", 2, Filter_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("deformable_conv_v1", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Output", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"Offset", {Offset}},{"Filter", {Filter}}};
    
    tracer->TraceOp("deformable_conv_v1", ins, outs, attrs);
    return outs["Output"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sequence_mask(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sequence_mask", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sequence_mask", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Y", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("sequence_mask", ins, outs, attrs);
    return outs["Y"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_sequence_enumerate(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("sequence_enumerate", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("sequence_enumerate", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("sequence_enumerate", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_reduce_sum(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("reduce_sum", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("reduce_sum", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("reduce_sum", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_reduce_all(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("reduce_all", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("reduce_all", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("reduce_all", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_teacher_student_sigmoid_loss(const py::handle& X_,const py::handle& Label_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("teacher_student_sigmoid_loss", "X", 0, X_, false);
  auto Label = CastPyHandleToVarBase("teacher_student_sigmoid_loss", "Label", 1, Label_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("teacher_student_sigmoid_loss", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Y", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Label", {Label}}};
    
    tracer->TraceOp("teacher_student_sigmoid_loss", ins, outs, attrs);
    return outs["Y"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_frobenius_norm(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("frobenius_norm", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("frobenius_norm", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}}};
    
    tracer->TraceOp("frobenius_norm", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_rmsprop(const py::handle& Param_,const py::handle& MeanSquare_,const py::handle& LearningRate_,const py::handle& Grad_,const py::handle& Moment_, const py::args& args)
{
  
  auto Param = CastPyHandleToVarBase("rmsprop", "Param", 0, Param_, false);
  auto MeanSquare = CastPyHandleToVarBase("rmsprop", "MeanSquare", 1, MeanSquare_, false);
  auto LearningRate = CastPyHandleToVarBase("rmsprop", "LearningRate", 2, LearningRate_, false);
  auto Grad = CastPyHandleToVarBase("rmsprop", "Grad", 3, Grad_, false);
  auto Moment = CastPyHandleToVarBase("rmsprop", "Moment", 4, Moment_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("rmsprop", 5, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"ParamOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"MomentOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"MeanSquareOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"MeanGradOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Param", {Param}},{"MeanSquare", {MeanSquare}},{"LearningRate", {LearningRate}},{"Grad", {Grad}},{"Moment", {Moment}}};
    
    tracer->TraceOp("rmsprop", ins, outs, attrs);
    return std::make_tuple(outs["ParamOut"][0],outs["MomentOut"][0],outs["MeanSquareOut"][0],outs["MeanGradOut"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_momentum(const py::handle& Param_,const py::handle& Grad_,const py::handle& Velocity_,const py::handle& LearningRate_,std::shared_ptr<imperative::VarBase>ParamOut,std::shared_ptr<imperative::VarBase>VelocityOut, const py::args& args)
{
  
  auto Param = CastPyHandleToVarBase("momentum", "Param", 0, Param_, false);
  auto Grad = CastPyHandleToVarBase("momentum", "Grad", 1, Grad_, false);
  auto Velocity = CastPyHandleToVarBase("momentum", "Velocity", 2, Velocity_, false);
  auto LearningRate = CastPyHandleToVarBase("momentum", "LearningRate", 3, LearningRate_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("momentum", 6, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"ParamOut", {ParamOut}},{"VelocityOut", {VelocityOut}}};
    imperative::NameVarBaseMap ins = {{"Param", {Param}},{"Grad", {Grad}},{"Velocity", {Velocity}},{"LearningRate", {LearningRate}}};
    
    tracer->TraceOp("momentum", ins, outs, attrs);
    return std::make_tuple(outs["ParamOut"][0],outs["VelocityOut"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_lars_momentum(const py::handle& Param_,const py::handle& Grad_,const py::handle& Velocity_,const py::handle& LearningRate_, const py::args& args)
{
  
  auto Param = CastPyHandleToVarBase("lars_momentum", "Param", 0, Param_, false);
  auto Grad = CastPyHandleToVarBase("lars_momentum", "Grad", 1, Grad_, false);
  auto Velocity = CastPyHandleToVarBase("lars_momentum", "Velocity", 2, Velocity_, false);
  auto LearningRate = CastPyHandleToVarBase("lars_momentum", "LearningRate", 3, LearningRate_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("lars_momentum", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"ParamOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"VelocityOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Param", {Param}},{"Grad", {Grad}},{"Velocity", {Velocity}},{"LearningRate", {LearningRate}}};
    
    tracer->TraceOp("lars_momentum", ins, outs, attrs);
    return std::make_tuple(outs["ParamOut"][0],outs["VelocityOut"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_lamb(const py::handle& Param_,const py::handle& Grad_,const py::handle& LearningRate_,const py::handle& Moment1_,const py::handle& Moment2_,const py::handle& Beta1Pow_,const py::handle& Beta2Pow_, const py::args& args)
{
  
  auto Param = CastPyHandleToVarBase("lamb", "Param", 0, Param_, false);
  auto Grad = CastPyHandleToVarBase("lamb", "Grad", 1, Grad_, false);
  auto LearningRate = CastPyHandleToVarBase("lamb", "LearningRate", 2, LearningRate_, false);
  auto Moment1 = CastPyHandleToVarBase("lamb", "Moment1", 3, Moment1_, false);
  auto Moment2 = CastPyHandleToVarBase("lamb", "Moment2", 4, Moment2_, false);
  auto Beta1Pow = CastPyHandleToVarBase("lamb", "Beta1Pow", 5, Beta1Pow_, false);
  auto Beta2Pow = CastPyHandleToVarBase("lamb", "Beta2Pow", 6, Beta2Pow_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("lamb", 7, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"ParamOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Moment1Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Moment2Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Param", {Param}},{"Grad", {Grad}},{"LearningRate", {LearningRate}},{"Moment1", {Moment1}},{"Moment2", {Moment2}},{"Beta1Pow", {Beta1Pow}},{"Beta2Pow", {Beta2Pow}}};
    
    tracer->TraceOp("lamb", ins, outs, attrs);
    return std::make_tuple(outs["ParamOut"][0],outs["Moment1Out"][0],outs["Moment2Out"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_dgc_momentum(const py::handle& current_step_,const py::handle& nranks_,const py::handle& Param_,const py::handle& Grad_,const py::handle& Velocity_,const py::handle& LearningRate_, const py::args& args)
{
  
  auto current_step = CastPyHandleToVarBase("dgc_momentum", "current_step", 0, current_step_, false);
  auto nranks = CastPyHandleToVarBase("dgc_momentum", "nranks", 1, nranks_, false);
  auto Param = CastPyHandleToVarBase("dgc_momentum", "Param", 2, Param_, false);
  auto Grad = CastPyHandleToVarBase("dgc_momentum", "Grad", 3, Grad_, false);
  auto Velocity = CastPyHandleToVarBase("dgc_momentum", "Velocity", 4, Velocity_, false);
  auto LearningRate = CastPyHandleToVarBase("dgc_momentum", "LearningRate", 5, LearningRate_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("dgc_momentum", 6, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Grad_out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"ParamOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"VelocityOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"current_step", {current_step}},{"nranks", {nranks}},{"Param", {Param}},{"Grad", {Grad}},{"Velocity", {Velocity}},{"LearningRate", {LearningRate}}};
    
    tracer->TraceOp("dgc_momentum", ins, outs, attrs);
    return std::make_tuple(outs["Grad_out"][0],outs["ParamOut"][0],outs["VelocityOut"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_multiclass_nms(const py::handle& BBoxes_,const py::handle& Scores_, const py::args& args)
{
  
  auto BBoxes = CastPyHandleToVarBase("multiclass_nms", "BBoxes", 0, BBoxes_, false);
  auto Scores = CastPyHandleToVarBase("multiclass_nms", "Scores", 1, Scores_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("multiclass_nms", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"BBoxes", {BBoxes}},{"Scores", {Scores}}};
    
    tracer->TraceOp("multiclass_nms", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_decayed_adagrad(const py::handle& Param_,const py::handle& Grad_,const py::handle& Moment_,const py::handle& LearningRate_, const py::args& args)
{
  
  auto Param = CastPyHandleToVarBase("decayed_adagrad", "Param", 0, Param_, false);
  auto Grad = CastPyHandleToVarBase("decayed_adagrad", "Grad", 1, Grad_, false);
  auto Moment = CastPyHandleToVarBase("decayed_adagrad", "Moment", 2, Moment_, false);
  auto LearningRate = CastPyHandleToVarBase("decayed_adagrad", "LearningRate", 3, LearningRate_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("decayed_adagrad", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"ParamOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"MomentOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Param", {Param}},{"Grad", {Grad}},{"Moment", {Moment}},{"LearningRate", {LearningRate}}};
    
    tracer->TraceOp("decayed_adagrad", ins, outs, attrs);
    return std::make_tuple(outs["ParamOut"][0],outs["MomentOut"][0]); 
  }   
}

std::vector<std::shared_ptr<imperative::VarBase>> imperative_fusion_group(const py::handle& Inputs_,size_t OutsNum, const py::args& args)
{
  
  auto Inputs = CastPyHandleToVarBaseList("fusion_group", "Inputs", 0, Inputs_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fusion_group", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Outs", ConstructDuplicableOutput(OutsNum)}};
    imperative::NameVarBaseMap ins = {{"Inputs", Inputs}};
    
    tracer->TraceOp("fusion_group", ins, outs, attrs);
    return outs["Outs"]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_multihead_matmul(const py::handle& Input_,const py::handle& W_,const py::handle& Bias_,const py::handle& BiasQK_, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("multihead_matmul", "Input", 0, Input_, false);
  auto W = CastPyHandleToVarBase("multihead_matmul", "W", 1, W_, false);
  auto Bias = CastPyHandleToVarBase("multihead_matmul", "Bias", 2, Bias_, false);
  auto BiasQK = CastPyHandleToVarBase("multihead_matmul", "BiasQK", 3, BiasQK_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("multihead_matmul", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"W", {W}},{"Bias", {Bias}},{"BiasQK", {BiasQK}}};
    
    tracer->TraceOp("multihead_matmul", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_fused_embedding_fc_lstm(const py::handle& Ids_,const py::handle& Embeddings_,const py::handle& WeightH_,const py::handle& Bias_, const py::args& args)
{
  
  auto Ids = CastPyHandleToVarBase("fused_embedding_fc_lstm", "Ids", 0, Ids_, false);
  auto Embeddings = CastPyHandleToVarBase("fused_embedding_fc_lstm", "Embeddings", 1, Embeddings_, false);
  auto WeightH = CastPyHandleToVarBase("fused_embedding_fc_lstm", "WeightH", 2, WeightH_, false);
  auto Bias = CastPyHandleToVarBase("fused_embedding_fc_lstm", "Bias", 3, Bias_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fused_embedding_fc_lstm", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Hidden", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Cell", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"XX", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"BatchedInput", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"BatchedHidden", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"BatchedCell", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"ReorderedH0", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"ReorderedC0", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Ids", {Ids}},{"Embeddings", {Embeddings}},{"WeightH", {WeightH}},{"Bias", {Bias}}};
    
    tracer->TraceOp("fused_embedding_fc_lstm", ins, outs, attrs);
    return std::make_tuple(outs["Hidden"][0],outs["Cell"][0],outs["XX"][0],outs["BatchedInput"][0],outs["BatchedHidden"][0],outs["BatchedCell"][0],outs["ReorderedH0"][0],outs["ReorderedC0"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::vector<std::shared_ptr<imperative::VarBase>>> imperative_conv2d_inception_fusion(const py::handle& Input_,const py::handle& Filter_,const py::handle& Bias_,size_t TempOutputNum, const py::args& args)
{
  
  auto Input = CastPyHandleToVarBase("conv2d_inception_fusion", "Input", 0, Input_, false);
  auto Filter = CastPyHandleToVarBaseList("conv2d_inception_fusion", "Filter", 1, Filter_, false);
  auto Bias = CastPyHandleToVarBaseList("conv2d_inception_fusion", "Bias", 2, Bias_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("conv2d_inception_fusion", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Output", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"TempOutput", ConstructDuplicableOutput(TempOutputNum)}};
    imperative::NameVarBaseMap ins = {{"Input", {Input}},{"Filter", Filter},{"Bias", Bias}};
    
    tracer->TraceOp("conv2d_inception_fusion", ins, outs, attrs);
    return std::make_tuple(outs["Output"][0],outs["TempOutput"]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_fill_constant(std::shared_ptr<imperative::VarBase>Out, const py::args& args)
{
  
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fill_constant", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {Out}}};
    imperative::NameVarBaseMap ins = {};
    
    tracer->TraceOp("fill_constant", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_fusion_transpose_flatten_concat(const py::handle& X_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBaseList("fusion_transpose_flatten_concat", "X", 0, X_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fusion_transpose_flatten_concat", 1, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", X}};
    
    tracer->TraceOp("fusion_transpose_flatten_concat", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_fused_batch_norm_act(const py::handle& X_,const py::handle& Scale_,const py::handle& Bias_,const py::handle& Mean_,const py::handle& Variance_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fused_batch_norm_act", "X", 0, X_, false);
  auto Scale = CastPyHandleToVarBase("fused_batch_norm_act", "Scale", 1, Scale_, false);
  auto Bias = CastPyHandleToVarBase("fused_batch_norm_act", "Bias", 2, Bias_, false);
  auto Mean = CastPyHandleToVarBase("fused_batch_norm_act", "Mean", 3, Mean_, false);
  auto Variance = CastPyHandleToVarBase("fused_batch_norm_act", "Variance", 4, Variance_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fused_batch_norm_act", 5, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Y", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"MeanOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"VarianceOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SavedMean", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"SavedVariance", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"ReserveSpace", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Scale", {Scale}},{"Bias", {Bias}},{"Mean", {Mean}},{"Variance", {Variance}}};
    
    tracer->TraceOp("fused_batch_norm_act", ins, outs, attrs);
    return std::make_tuple(outs["Y"][0],outs["MeanOut"][0],outs["VarianceOut"][0],outs["SavedMean"][0],outs["SavedVariance"][0],outs["ReserveSpace"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_box_decoder_and_assign(const py::handle& PriorBox_,const py::handle& TargetBox_,const py::handle& BoxScore_, const py::args& args)
{
  
  auto PriorBox = CastPyHandleToVarBase("box_decoder_and_assign", "PriorBox", 0, PriorBox_, false);
  auto TargetBox = CastPyHandleToVarBase("box_decoder_and_assign", "TargetBox", 1, TargetBox_, false);
  auto BoxScore = CastPyHandleToVarBase("box_decoder_and_assign", "BoxScore", 2, BoxScore_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("box_decoder_and_assign", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"DecodeBox", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"OutputAssignBox", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"PriorBox", {PriorBox}},{"TargetBox", {TargetBox}},{"BoxScore", {BoxScore}}};
    
    tracer->TraceOp("box_decoder_and_assign", ins, outs, attrs);
    return std::make_tuple(outs["DecodeBox"][0],outs["OutputAssignBox"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_dist(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("dist", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("dist", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("dist", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("dist", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_average_accumulates(const py::handle& param_,const py::handle& in_sum_1_,const py::handle& in_sum_2_,const py::handle& in_sum_3_,const py::handle& in_num_accumulates_,const py::handle& in_old_num_accumulates_,const py::handle& in_num_updates_, const py::args& args)
{
  
  auto param = CastPyHandleToVarBase("average_accumulates", "param", 0, param_, false);
  auto in_sum_1 = CastPyHandleToVarBase("average_accumulates", "in_sum_1", 1, in_sum_1_, false);
  auto in_sum_2 = CastPyHandleToVarBase("average_accumulates", "in_sum_2", 2, in_sum_2_, false);
  auto in_sum_3 = CastPyHandleToVarBase("average_accumulates", "in_sum_3", 3, in_sum_3_, false);
  auto in_num_accumulates = CastPyHandleToVarBase("average_accumulates", "in_num_accumulates", 4, in_num_accumulates_, false);
  auto in_old_num_accumulates = CastPyHandleToVarBase("average_accumulates", "in_old_num_accumulates", 5, in_old_num_accumulates_, false);
  auto in_num_updates = CastPyHandleToVarBase("average_accumulates", "in_num_updates", 6, in_num_updates_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("average_accumulates", 7, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"out_sum_1", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"out_sum_2", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"out_sum_3", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"out_num_accumulates", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"out_old_num_accumulates", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"out_num_updates", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"param", {param}},{"in_sum_1", {in_sum_1}},{"in_sum_2", {in_sum_2}},{"in_sum_3", {in_sum_3}},{"in_num_accumulates", {in_num_accumulates}},{"in_old_num_accumulates", {in_old_num_accumulates}},{"in_num_updates", {in_num_updates}}};
    
    tracer->TraceOp("average_accumulates", ins, outs, attrs);
    return std::make_tuple(outs["out_sum_1"][0],outs["out_sum_2"][0],outs["out_sum_3"][0],outs["out_num_accumulates"][0],outs["out_old_num_accumulates"][0],outs["out_num_updates"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_fusion_seqexpand_concat_fc(const py::handle& X_,const py::handle& FCWeight_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBaseList("fusion_seqexpand_concat_fc", "X", 0, X_, false);
  auto FCWeight = CastPyHandleToVarBase("fusion_seqexpand_concat_fc", "FCWeight", 1, FCWeight_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fusion_seqexpand_concat_fc", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"FCOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", X},{"FCWeight", {FCWeight}}};
    
    tracer->TraceOp("fusion_seqexpand_concat_fc", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["FCOut"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_fusion_seqconv_eltadd_relu(const py::handle& X_,const py::handle& Filter_,const py::handle& Bias_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fusion_seqconv_eltadd_relu", "X", 0, X_, false);
  auto Filter = CastPyHandleToVarBase("fusion_seqconv_eltadd_relu", "Filter", 1, Filter_, false);
  auto Bias = CastPyHandleToVarBase("fusion_seqconv_eltadd_relu", "Bias", 2, Bias_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fusion_seqconv_eltadd_relu", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"ColMat", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Filter", {Filter}},{"Bias", {Bias}}};
    
    tracer->TraceOp("fusion_seqconv_eltadd_relu", ins, outs, attrs);
    return std::make_tuple(outs["Out"][0],outs["ColMat"][0]); 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_fusion_lstm(const py::handle& X_,const py::handle& WeightX_,const py::handle& WeightH_,const py::handle& Bias_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("fusion_lstm", "X", 0, X_, false);
  auto WeightX = CastPyHandleToVarBase("fusion_lstm", "WeightX", 1, WeightX_, false);
  auto WeightH = CastPyHandleToVarBase("fusion_lstm", "WeightH", 2, WeightH_, false);
  auto Bias = CastPyHandleToVarBase("fusion_lstm", "Bias", 3, Bias_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("fusion_lstm", 4, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Hidden", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"Cell", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"XX", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"BatchedInput", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"BatchedHidden", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"BatchedCell", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"ReorderedH0", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"ReorderedC0", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"CheckedCell", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"WeightX", {WeightX}},{"WeightH", {WeightH}},{"Bias", {Bias}}};
    
    tracer->TraceOp("fusion_lstm", ins, outs, attrs);
    return std::make_tuple(outs["Hidden"][0],outs["Cell"][0],outs["XX"][0],outs["BatchedInput"][0],outs["BatchedHidden"][0],outs["BatchedCell"][0],outs["ReorderedH0"][0],outs["ReorderedC0"][0],outs["CheckedCell"][0]); 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_elementwise_mul(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("elementwise_mul", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("elementwise_mul", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("elementwise_mul", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("elementwise_mul", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_logical_and(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("logical_and", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("logical_and", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("logical_and", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("logical_and", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_elementwise_max(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("elementwise_max", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("elementwise_max", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("elementwise_max", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("elementwise_max", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_dequantize_log(const py::handle& X_,const py::handle& Dict_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("dequantize_log", "X", 0, X_, false);
  auto Dict = CastPyHandleToVarBase("dequantize_log", "Dict", 1, Dict_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("dequantize_log", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Dict", {Dict}}};
    
    tracer->TraceOp("dequantize_log", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_elementwise_floordiv(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("elementwise_floordiv", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("elementwise_floordiv", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("elementwise_floordiv", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("elementwise_floordiv", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_elementwise_div(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("elementwise_div", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("elementwise_div", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("elementwise_div", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("elementwise_div", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_elementwise_add(const py::handle& X_,const py::handle& Y_, const py::args& args)
{
  
  auto X = CastPyHandleToVarBase("elementwise_add", "X", 0, X_, false);
  auto Y = CastPyHandleToVarBase("elementwise_add", "Y", 1, Y_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("elementwise_add", 2, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"Out", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"X", {X}},{"Y", {Y}}};
    
    tracer->TraceOp("elementwise_add", ins, outs, attrs);
    return outs["Out"][0]; 
  }   
}

std::shared_ptr<imperative::VarBase> imperative_dpsgd(const py::handle& Param_,const py::handle& Grad_,const py::handle& LearningRate_, const py::args& args)
{
  
  auto Param = CastPyHandleToVarBase("dpsgd", "Param", 0, Param_, false);
  auto Grad = CastPyHandleToVarBase("dpsgd", "Grad", 1, Grad_, false);
  auto LearningRate = CastPyHandleToVarBase("dpsgd", "LearningRate", 2, LearningRate_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("dpsgd", 3, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"ParamOut", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"Param", {Param}},{"Grad", {Grad}},{"LearningRate", {LearningRate}}};
    
    tracer->TraceOp("dpsgd", ins, outs, attrs);
    return outs["ParamOut"][0]; 
  }   
}

std::tuple<std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>,std::shared_ptr<imperative::VarBase>> imperative_generate_mask_labels(const py::handle& ImInfo_,const py::handle& GtClasses_,const py::handle& IsCrowd_,const py::handle& GtSegms_,const py::handle& Rois_,const py::handle& LabelsInt32_, const py::args& args)
{
  
  auto ImInfo = CastPyHandleToVarBase("generate_mask_labels", "ImInfo", 0, ImInfo_, false);
  auto GtClasses = CastPyHandleToVarBase("generate_mask_labels", "GtClasses", 1, GtClasses_, false);
  auto IsCrowd = CastPyHandleToVarBase("generate_mask_labels", "IsCrowd", 2, IsCrowd_, false);
  auto GtSegms = CastPyHandleToVarBase("generate_mask_labels", "GtSegms", 3, GtSegms_, false);
  auto Rois = CastPyHandleToVarBase("generate_mask_labels", "Rois", 4, Rois_, false);
  auto LabelsInt32 = CastPyHandleToVarBase("generate_mask_labels", "LabelsInt32", 5, LabelsInt32_, false);
  framework::AttributeMap attrs;
  ConstructAttrMapFromPyArgs("generate_mask_labels", 6, &attrs, args);
  {
    py::gil_scoped_release release;
    auto tracer = imperative::GetCurrentTracer();
    imperative::NameVarBaseMap outs = {{"MaskRois", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"RoiHasMaskInt32", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}},{"MaskInt32", {std::shared_ptr<imperative::VarBase>(new imperative::VarBase(tracer->GenerateUniqueName()))}}};
    imperative::NameVarBaseMap ins = {{"ImInfo", {ImInfo}},{"GtClasses", {GtClasses}},{"IsCrowd", {IsCrowd}},{"GtSegms", {GtSegms}},{"Rois", {Rois}},{"LabelsInt32", {LabelsInt32}}};
    
    tracer->TraceOp("generate_mask_labels", ins, outs, attrs);
    return std::make_tuple(outs["MaskRois"][0],outs["RoiHasMaskInt32"][0],outs["MaskInt32"][0]); 
  }   
}

inline void BindOpFunctions(pybind11::module *module) {
  auto m = module->def_submodule("ops");

  m.def("equal_all", &imperative_equal_all);
  m.def("not_equal", &imperative_not_equal);
  m.def("greater_equal", &imperative_greater_equal);
  m.def("greater_than", &imperative_greater_than);
  m.def("less_equal", &imperative_less_equal);
  m.def("less_than", &imperative_less_than);
  m.def("logical_xor", &imperative_logical_xor);
  m.def("logical_not", &imperative_logical_not);
  m.def("logical_or", &imperative_logical_or);
  m.def("mine_hard_examples", &imperative_mine_hard_examples);
  m.def("prior_box", &imperative_prior_box);
  m.def("anchor_generator", &imperative_anchor_generator);
  m.def("target_assign", &imperative_target_assign);
  m.def("retinanet_target_assign", &imperative_retinanet_target_assign);
  m.def("rpn_target_assign", &imperative_rpn_target_assign);
  m.def("generate_proposal_labels", &imperative_generate_proposal_labels);
  m.def("multiclass_nms2", &imperative_multiclass_nms2);
  m.def("locality_aware_nms", &imperative_locality_aware_nms);
  m.def("matrix_nms", &imperative_matrix_nms);
  m.def("box_clip", &imperative_box_clip);
  m.def("bipartite_match", &imperative_bipartite_match);
  m.def("sigmoid_focal_loss", &imperative_sigmoid_focal_loss);
  m.def("gather_tree", &imperative_gather_tree);
  m.def("gaussian_random", &imperative_gaussian_random);
  m.def("gelu", &imperative_gelu);
  m.def("get_tensor_from_selected_rows", &imperative_get_tensor_from_selected_rows);
  m.def("sequence_expand_as", &imperative_sequence_expand_as);
  m.def("lookup_table_v2", &imperative_lookup_table_v2);
  m.def("pad2d", &imperative_pad2d);
  m.def("size", &imperative_size);
  m.def("hinge_loss", &imperative_hinge_loss);
  m.def("conv2d_transpose", &imperative_conv2d_transpose);
  m.def("huber_loss", &imperative_huber_loss);
  m.def("pixel_shuffle", &imperative_pixel_shuffle);
  m.def("increment", &imperative_increment);
  m.def("inplace_abn", &imperative_inplace_abn);
  m.def("sinh", &imperative_sinh);
  m.def("trilinear_interp", &imperative_trilinear_interp);
  m.def("thresholded_relu", &imperative_thresholded_relu);
  m.def("pull_sparse", &imperative_pull_sparse);
  m.def("linear_interp_v2", &imperative_linear_interp_v2);
  m.def("yolov3_loss", &imperative_yolov3_loss);
  m.def("hard_shrink", &imperative_hard_shrink);
  m.def("elu", &imperative_elu);
  m.def("bilinear_interp_v2", &imperative_bilinear_interp_v2);
  m.def("cross", &imperative_cross);
  m.def("inverse", &imperative_inverse);
  m.def("reduce_max", &imperative_reduce_max);
  m.def("hash", &imperative_hash);
  m.def("grid_sampler", &imperative_grid_sampler);
  m.def("squeeze", &imperative_squeeze);
  m.def("one_hot_v2", &imperative_one_hot_v2);
  m.def("isnan", &imperative_isnan);
  m.def("dot", &imperative_dot);
  m.def("ncclReduce", &imperative_ncclReduce);
  m.def("hierarchical_sigmoid", &imperative_hierarchical_sigmoid);
  m.def("isinf", &imperative_isinf);
  m.def("isfinite_v2", &imperative_isfinite_v2);
  m.def("clip_by_norm", &imperative_clip_by_norm);
  m.def("index_sample", &imperative_index_sample);
  m.def("partial_sum", &imperative_partial_sum);
  m.def("layer_norm", &imperative_layer_norm);
  m.def("load_combine", &imperative_load_combine);
  m.def("sequence_erase", &imperative_sequence_erase);
  m.def("log_loss", &imperative_log_loss);
  m.def("log_softmax", &imperative_log_softmax);
  m.def("asin", &imperative_asin);
  m.def("box_coder", &imperative_box_coder);
  m.def("correlation", &imperative_correlation);
  m.def("lrn", &imperative_lrn);
  m.def("nearest_interp_v2", &imperative_nearest_interp_v2);
  m.def("lstm_unit", &imperative_lstm_unit);
  m.def("margin_rank_loss", &imperative_margin_rank_loss);
  m.def("masked_select", &imperative_masked_select);
  m.def("matmul", &imperative_matmul);
  m.def("matmul_v2", &imperative_matmul_v2);
  m.def("multiclass_nms3", &imperative_multiclass_nms3);
  m.def("eye", &imperative_eye);
  m.def("isfinite", &imperative_isfinite);
  m.def("im2sequence", &imperative_im2sequence);
  m.def("crf_decoding", &imperative_crf_decoding);
  m.def("fused_embedding_seq_pool", &imperative_fused_embedding_seq_pool);
  m.def("mean_iou", &imperative_mean_iou);
  m.def("merge_selected_rows", &imperative_merge_selected_rows);
  m.def("meshgrid", &imperative_meshgrid);
  m.def("argsort", &imperative_argsort);
  m.def("minus", &imperative_minus);
  m.def("adadelta", &imperative_adadelta);
  m.def("lod_reset", &imperative_lod_reset);
  m.def("mish", &imperative_mish);
  m.def("modified_huber_loss", &imperative_modified_huber_loss);
  m.def("skip_layernorm", &imperative_skip_layernorm);
  m.def("mul", &imperative_mul);
  m.def("log10", &imperative_log10);
  m.def("proximal_gd", &imperative_proximal_gd);
  m.def("multinomial", &imperative_multinomial);
  m.def("dgc_clip_by_norm", &imperative_dgc_clip_by_norm);
  m.def("bilateral_slice", &imperative_bilateral_slice);
  m.def("multiplex", &imperative_multiplex);
  m.def("nll_loss", &imperative_nll_loss);
  m.def("sequence_expand", &imperative_sequence_expand);
  m.def("unbind", &imperative_unbind);
  m.def("linear_chain_crf", &imperative_linear_chain_crf);
  m.def("norm", &imperative_norm);
  m.def("lstm", &imperative_lstm);
  m.def("mean", &imperative_mean);
  m.def("filter_by_instag", &imperative_filter_by_instag);
  m.def("sequence_scatter", &imperative_sequence_scatter);
  m.def("p_norm", &imperative_p_norm);
  m.def("load", &imperative_load);
  m.def("expand_v2", &imperative_expand_v2);
  m.def("mv", &imperative_mv);
  m.def("detection_map", &imperative_detection_map);
  m.def("fused_elemwise_activation", &imperative_fused_elemwise_activation);
  m.def("pool3d", &imperative_pool3d);
  m.def("pool2d", &imperative_pool2d);
  m.def("max_pool2d_with_index", &imperative_max_pool2d_with_index);
  m.def("polygon_box_transform", &imperative_polygon_box_transform);
  m.def("center_loss", &imperative_center_loss);
  m.def("positive_negative_pair", &imperative_positive_negative_pair);
  m.def("fused_embedding_eltwise_layernorm", &imperative_fused_embedding_eltwise_layernorm);
  m.def("nearest_interp", &imperative_nearest_interp);
  m.def("softmax_with_cross_entropy", &imperative_softmax_with_cross_entropy);
  m.def("scatter", &imperative_scatter);
  m.def("shard_index", &imperative_shard_index);
  m.def("conj", &imperative_conj);
  m.def("lstmp", &imperative_lstmp);
  m.def("split", &imperative_split);
  m.def("run_program", &imperative_run_program);
  m.def("stack", &imperative_stack);
  m.def("strided_slice", &imperative_strided_slice);
  m.def("split_selected_rows", &imperative_split_selected_rows);
  m.def("similarity_focus", &imperative_similarity_focus);
  m.def("histogram", &imperative_histogram);
  m.def("top_k", &imperative_top_k);
  m.def("fill_zeros_like", &imperative_fill_zeros_like);
  m.def("save_combine", &imperative_save_combine);
  m.def("sequence_reshape", &imperative_sequence_reshape);
  m.def("auc", &imperative_auc);
  m.def("adagrad", &imperative_adagrad);
  m.def("fsp", &imperative_fsp);
  m.def("tile", &imperative_tile);
  m.def("flatten2", &imperative_flatten2);
  m.def("fake_quantize_moving_average_abs_max", &imperative_fake_quantize_moving_average_abs_max);
  m.def("roll", &imperative_roll);
  m.def("space_to_depth", &imperative_space_to_depth);
  m.def("partial_concat", &imperative_partial_concat);
  m.def("flatten", &imperative_flatten);
  m.def("spectral_norm", &imperative_spectral_norm);
  m.def("shuffle_batch", &imperative_shuffle_batch);
  m.def("gather", &imperative_gather);
  m.def("adamax", &imperative_adamax);
  m.def("softmax", &imperative_softmax);
  m.def("trilinear_interp_v2", &imperative_trilinear_interp_v2);
  m.def("reduce_any", &imperative_reduce_any);
  m.def("save", &imperative_save);
  m.def("equal", &imperative_equal);
  m.def("tril_triu", &imperative_tril_triu);
  m.def("tree_conv", &imperative_tree_conv);
  m.def("pad", &imperative_pad);
  m.def("fusion_squared_mat_sub", &imperative_fusion_squared_mat_sub);
  m.def("maxout", &imperative_maxout);
  m.def("fake_dequantize_max_abs", &imperative_fake_dequantize_max_abs);
  m.def("unique_with_counts", &imperative_unique_with_counts);
  m.def("where_index", &imperative_where_index);
  m.def("truncated_gaussian_random", &imperative_truncated_gaussian_random);
  m.def("sequence_pad", &imperative_sequence_pad);
  m.def("fake_channel_wise_quantize_dequantize_abs_max", &imperative_fake_channel_wise_quantize_dequantize_abs_max);
  m.def("spp", &imperative_spp);
  m.def("sync_batch_norm", &imperative_sync_batch_norm);
  m.def("generate_proposals_v2", &imperative_generate_proposals_v2);
  m.def("randperm", &imperative_randperm);
  m.def("set_value", &imperative_set_value);
  m.def("index_select", &imperative_index_select);
  m.def("push_dense", &imperative_push_dense);
  m.def("cross_entropy", &imperative_cross_entropy);
  m.def("uniform_random", &imperative_uniform_random);
  m.def("top_k_v2", &imperative_top_k_v2);
  m.def("bilinear_interp", &imperative_bilinear_interp);
  m.def("sequence_concat", &imperative_sequence_concat);
  m.def("unsqueeze", &imperative_unsqueeze);
  m.def("linspace", &imperative_linspace);
  m.def("fc", &imperative_fc);
  m.def("slice", &imperative_slice);
  m.def("tdm_sampler", &imperative_tdm_sampler);
  m.def("unstack", &imperative_unstack);
  m.def("where", &imperative_where);
  m.def("seed", &imperative_seed);
  m.def("unique", &imperative_unique);
  m.def("uniform_random_batch_size_like", &imperative_uniform_random_batch_size_like);
  m.def("sgd", &imperative_sgd);
  m.def("data_norm", &imperative_data_norm);
  m.def("warpctc", &imperative_warpctc);
  m.def("kldiv_loss", &imperative_kldiv_loss);
  m.def("lookup_table_dequant", &imperative_lookup_table_dequant);
  m.def("smooth_l1_loss", &imperative_smooth_l1_loss);
  m.def("reshape", &imperative_reshape);
  m.def("tdm_child", &imperative_tdm_child);
  m.def("stanh", &imperative_stanh);
  m.def("gru", &imperative_gru);
  m.def("log2", &imperative_log2);
  m.def("nce", &imperative_nce);
  m.def("label_smooth", &imperative_label_smooth);
  m.def("sigmoid_cross_entropy_with_logits", &imperative_sigmoid_cross_entropy_with_logits);
  m.def("temporal_shift", &imperative_temporal_shift);
  m.def("pad3d", &imperative_pad3d);
  m.def("cudnn_lstm", &imperative_cudnn_lstm);
  m.def("flip", &imperative_flip);
  m.def("rank_loss", &imperative_rank_loss);
  m.def("bernoulli", &imperative_bernoulli);
  m.def("scatter_nd_add", &imperative_scatter_nd_add);
  m.def("depthwise_conv2d_transpose", &imperative_depthwise_conv2d_transpose);
  m.def("batch_fc", &imperative_batch_fc);
  m.def("selu", &imperative_selu);
  m.def("reduce_mean", &imperative_reduce_mean);
  m.def("isinf_v2", &imperative_isinf_v2);
  m.def("shape", &imperative_shape);
  m.def("logsigmoid", &imperative_logsigmoid);
  m.def("sampling_id", &imperative_sampling_id);
  m.def("unpool", &imperative_unpool);
  m.def("segment_pool", &imperative_segment_pool);
  m.def("lookup_table", &imperative_lookup_table);
  m.def("pull_box_sparse", &imperative_pull_box_sparse);
  m.def("real", &imperative_real);
  m.def("bicubic_interp", &imperative_bicubic_interp);
  m.def("sample_logits", &imperative_sample_logits);
  m.def("sequence_topk_avg_pooling", &imperative_sequence_topk_avg_pooling);
  m.def("acos", &imperative_acos);
  m.def("rnn", &imperative_rnn);
  m.def("fake_quantize_dequantize_moving_average_abs_max", &imperative_fake_quantize_dequantize_moving_average_abs_max);
  m.def("fusion_seqpool_cvm_concat", &imperative_fusion_seqpool_cvm_concat);
  m.def("sign", &imperative_sign);
  m.def("expand_as", &imperative_expand_as);
  m.def("bicubic_interp_v2", &imperative_bicubic_interp_v2);
  m.def("isnan_v2", &imperative_isnan_v2);
  m.def("arg_max", &imperative_arg_max);
  m.def("roi_pool", &imperative_roi_pool);
  m.def("roi_align", &imperative_roi_align);
  m.def("unsqueeze2", &imperative_unsqueeze2);
  m.def("random_crop", &imperative_random_crop);
  m.def("diag_embed", &imperative_diag_embed);
  m.def("squared_l2_norm", &imperative_squared_l2_norm);
  m.def("fusion_seqpool_concat", &imperative_fusion_seqpool_concat);
  m.def("gaussian_random_batch_size_like", &imperative_gaussian_random_batch_size_like);
  m.def("beam_search", &imperative_beam_search);
  m.def("reverse", &imperative_reverse);
  m.def("l1_norm", &imperative_l1_norm);
  m.def("expand", &imperative_expand);
  m.def("gru_unit", &imperative_gru_unit);
  m.def("grad_add", &imperative_grad_add);
  m.def("rank_attention", &imperative_rank_attention);
  m.def("range", &imperative_range);
  m.def("one_hot", &imperative_one_hot);
  m.def("fusion_repeated_fc_relu", &imperative_fusion_repeated_fc_relu);
  m.def("randint", &imperative_randint);
  m.def("gather_nd", &imperative_gather_nd);
  m.def("squared_l2_distance", &imperative_squared_l2_distance);
  m.def("yolo_box", &imperative_yolo_box);
  m.def("transpose2", &imperative_transpose2);
  m.def("empty", &imperative_empty);
  m.def("elementwise_min", &imperative_elementwise_min);
  m.def("update_loss_scaling", &imperative_update_loss_scaling);
  m.def("pyramid_hash", &imperative_pyramid_hash);
  m.def("accuracy", &imperative_accuracy);
  m.def("pull_sparse_v2", &imperative_pull_sparse_v2);
  m.def("logsumexp", &imperative_logsumexp);
  m.def("pull_box_extended_sparse", &imperative_pull_box_extended_sparse);
  m.def("instance_norm", &imperative_instance_norm);
  m.def("psroi_pool", &imperative_psroi_pool);
  m.def("iou_similarity", &imperative_iou_similarity);
  m.def("linear_interp", &imperative_linear_interp);
  m.def("max_pool3d_with_index", &imperative_max_pool3d_with_index);
  m.def("sum", &imperative_sum);
  m.def("reshape2", &imperative_reshape2);
  m.def("flatten_contiguous_range", &imperative_flatten_contiguous_range);
  m.def("fake_quantize_range_abs_max", &imperative_fake_quantize_range_abs_max);
  m.def("deformable_psroi_pooling", &imperative_deformable_psroi_pooling);
  m.def("attention_lstm", &imperative_attention_lstm);
  m.def("fill_zeros_like2", &imperative_fill_zeros_like2);
  m.def("fill", &imperative_fill);
  m.def("diag", &imperative_diag);
  m.def("tanh_shrink", &imperative_tanh_shrink);
  m.def("fill_any_like", &imperative_fill_any_like);
  m.def("proximal_adagrad", &imperative_proximal_adagrad);
  m.def("fake_quantize_dequantize_abs_max", &imperative_fake_quantize_dequantize_abs_max);
  m.def("ncclAllReduce", &imperative_ncclAllReduce);
  m.def("fake_channel_wise_quantize_abs_max", &imperative_fake_channel_wise_quantize_abs_max);
  m.def("density_prior_box", &imperative_density_prior_box);
  m.def("moving_average_abs_max_scale", &imperative_moving_average_abs_max_scale);
  m.def("fake_channel_wise_dequantize_max_abs", &imperative_fake_channel_wise_dequantize_max_abs);
  m.def("chunk_eval", &imperative_chunk_eval);
  m.def("erf", &imperative_erf);
  m.def("dropout", &imperative_dropout);
  m.def("diag_v2", &imperative_diag_v2);
  m.def("cholesky", &imperative_cholesky);
  m.def("fill_constant_batch_size_like", &imperative_fill_constant_batch_size_like);
  m.def("expand_as_v2", &imperative_expand_as_v2);
  m.def("dequantize_abs_max", &imperative_dequantize_abs_max);
  m.def("deformable_conv", &imperative_deformable_conv);
  m.def("sigmoid", &imperative_sigmoid);
  m.def("log1p", &imperative_log1p);
  m.def("cumsum", &imperative_cumsum);
  m.def("ctc_align", &imperative_ctc_align);
  m.def("imag", &imperative_imag);
  m.def("transpose", &imperative_transpose);
  m.def("roi_perspective_transform", &imperative_roi_perspective_transform);
  m.def("crop_tensor", &imperative_crop_tensor);
  m.def("sequence_unpad", &imperative_sequence_unpad);
  m.def("crop", &imperative_crop);
  m.def("log", &imperative_log);
  m.def("conv3d_transpose", &imperative_conv3d_transpose);
  m.def("conv2d_fusion", &imperative_conv2d_fusion);
  m.def("cos_sim", &imperative_cos_sim);
  m.def("cvm", &imperative_cvm);
  m.def("fused_bn_add_activation", &imperative_fused_bn_add_activation);
  m.def("conv_shift", &imperative_conv_shift);
  m.def("scale", &imperative_scale);
  m.def("conv2d", &imperative_conv2d);
  m.def("depthwise_conv2d", &imperative_depthwise_conv2d);
  m.def("reduce_prod", &imperative_reduce_prod);
  m.def("add_position_encoding", &imperative_add_position_encoding);
  m.def("reduce_min", &imperative_reduce_min);
  m.def("conv3d", &imperative_conv3d);
  m.def("squeeze2", &imperative_squeeze2);
  m.def("concat", &imperative_concat);
  m.def("clip", &imperative_clip);
  m.def("cast", &imperative_cast);
  m.def("distribute_fpn_proposals", &imperative_distribute_fpn_proposals);
  m.def("bmm", &imperative_bmm);
  m.def("bilinear_tensor_product", &imperative_bilinear_tensor_product);
  m.def("elementwise_pow", &imperative_elementwise_pow);
  m.def("ftrl", &imperative_ftrl);
  m.def("kron", &imperative_kron);
  m.def("prelu", &imperative_prelu);
  m.def("bce_loss", &imperative_bce_loss);
  m.def("generate_proposals", &imperative_generate_proposals);
  m.def("batch_norm", &imperative_batch_norm);
  m.def("assign_value", &imperative_assign_value);
  m.def("cross_entropy2", &imperative_cross_entropy2);
  m.def("assign", &imperative_assign);
  m.def("arg_min", &imperative_arg_min);
  m.def("group_norm", &imperative_group_norm);
  m.def("brelu", &imperative_brelu);
  m.def("is_empty", &imperative_is_empty);
  m.def("allclose", &imperative_allclose);
  m.def("affine_grid", &imperative_affine_grid);
  m.def("affine_channel", &imperative_affine_channel);
  m.def("addmm", &imperative_addmm);
  m.def("fused_fc_elementwise_layernorm", &imperative_fused_fc_elementwise_layernorm);
  m.def("tanh", &imperative_tanh);
  m.def("retinanet_detection_output", &imperative_retinanet_detection_output);
  m.def("prroi_pool", &imperative_prroi_pool);
  m.def("atan", &imperative_atan);
  m.def("softshrink", &imperative_softshrink);
  m.def("softplus", &imperative_softplus);
  m.def("ceil", &imperative_ceil);
  m.def("floor", &imperative_floor);
  m.def("exp", &imperative_exp);
  m.def("cos", &imperative_cos);
  m.def("tan", &imperative_tan);
  m.def("collect_fpn_proposals", &imperative_collect_fpn_proposals);
  m.def("shuffle_channel", &imperative_shuffle_channel);
  m.def("sequence_conv", &imperative_sequence_conv);
  m.def("sin", &imperative_sin);
  m.def("edit_distance", &imperative_edit_distance);
  m.def("cosh", &imperative_cosh);
  m.def("reciprocal", &imperative_reciprocal);
  m.def("round", &imperative_round);
  m.def("soft_relu", &imperative_soft_relu);
  m.def("bpr_loss", &imperative_bpr_loss);
  m.def("softsign", &imperative_softsign);
  m.def("trace", &imperative_trace);
  m.def("adam", &imperative_adam);
  m.def("elementwise_sub", &imperative_elementwise_sub);
  m.def("relu6", &imperative_relu6);
  m.def("hard_sigmoid", &imperative_hard_sigmoid);
  m.def("pad_constant_like", &imperative_pad_constant_like);
  m.def("swish", &imperative_swish);
  m.def("hard_swish", &imperative_hard_swish);
  m.def("relu", &imperative_relu);
  m.def("precision_recall", &imperative_precision_recall);
  m.def("leaky_relu", &imperative_leaky_relu);
  m.def("unfold", &imperative_unfold);
  m.def("sqrt", &imperative_sqrt);
  m.def("rsqrt", &imperative_rsqrt);
  m.def("elementwise_mod", &imperative_elementwise_mod);
  m.def("fake_quantize_abs_max", &imperative_fake_quantize_abs_max);
  m.def("pow", &imperative_pow);
  m.def("square", &imperative_square);
  m.def("abs", &imperative_abs);
  m.def("coalesce_tensor", &imperative_coalesce_tensor);
  m.def("row_conv", &imperative_row_conv);
  m.def("sequence_reverse", &imperative_sequence_reverse);
  m.def("ncclBcast", &imperative_ncclBcast);
  m.def("fusion_gru", &imperative_fusion_gru);
  m.def("check_finite_and_unscale", &imperative_check_finite_and_unscale);
  m.def("sequence_softmax", &imperative_sequence_softmax);
  m.def("sequence_slice", &imperative_sequence_slice);
  m.def("sequence_pool", &imperative_sequence_pool);
  m.def("deformable_conv_v1", &imperative_deformable_conv_v1);
  m.def("sequence_mask", &imperative_sequence_mask);
  m.def("sequence_enumerate", &imperative_sequence_enumerate);
  m.def("reduce_sum", &imperative_reduce_sum);
  m.def("reduce_all", &imperative_reduce_all);
  m.def("teacher_student_sigmoid_loss", &imperative_teacher_student_sigmoid_loss);
  m.def("frobenius_norm", &imperative_frobenius_norm);
  m.def("rmsprop", &imperative_rmsprop);
  m.def("momentum", &imperative_momentum);
  m.def("lars_momentum", &imperative_lars_momentum);
  m.def("lamb", &imperative_lamb);
  m.def("dgc_momentum", &imperative_dgc_momentum);
  m.def("multiclass_nms", &imperative_multiclass_nms);
  m.def("decayed_adagrad", &imperative_decayed_adagrad);
  m.def("fusion_group", &imperative_fusion_group);
  m.def("multihead_matmul", &imperative_multihead_matmul);
  m.def("fused_embedding_fc_lstm", &imperative_fused_embedding_fc_lstm);
  m.def("conv2d_inception_fusion", &imperative_conv2d_inception_fusion);
  m.def("fill_constant", &imperative_fill_constant);
  m.def("fusion_transpose_flatten_concat", &imperative_fusion_transpose_flatten_concat);
  m.def("fused_batch_norm_act", &imperative_fused_batch_norm_act);
  m.def("box_decoder_and_assign", &imperative_box_decoder_and_assign);
  m.def("dist", &imperative_dist);
  m.def("average_accumulates", &imperative_average_accumulates);
  m.def("fusion_seqexpand_concat_fc", &imperative_fusion_seqexpand_concat_fc);
  m.def("fusion_seqconv_eltadd_relu", &imperative_fusion_seqconv_eltadd_relu);
  m.def("fusion_lstm", &imperative_fusion_lstm);
  m.def("elementwise_mul", &imperative_elementwise_mul);
  m.def("logical_and", &imperative_logical_and);
  m.def("elementwise_max", &imperative_elementwise_max);
  m.def("dequantize_log", &imperative_dequantize_log);
  m.def("elementwise_floordiv", &imperative_elementwise_floordiv);
  m.def("elementwise_div", &imperative_elementwise_div);
  m.def("elementwise_add", &imperative_elementwise_add);
  m.def("dpsgd", &imperative_dpsgd);
  m.def("generate_mask_labels", &imperative_generate_mask_labels);
}

} // namespace pybind
} // namespace paddle
